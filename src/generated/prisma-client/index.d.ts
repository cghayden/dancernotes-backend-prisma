// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  accessRequest: (where?: AccessRequestWhereInput) => Promise<boolean>;
  customRoutine: (where?: CustomRoutineWhereInput) => Promise<boolean>;
  danceClass: (where?: DanceClassWhereInput) => Promise<boolean>;
  dancer: (where?: DancerWhereInput) => Promise<boolean>;
  enrollmentRequest: (where?: EnrollmentRequestWhereInput) => Promise<boolean>;
  hairStyle: (where?: HairStyleWhereInput) => Promise<boolean>;
  makeupSet: (where?: MakeupSetWhereInput) => Promise<boolean>;
  parent: (where?: ParentWhereInput) => Promise<boolean>;
  parentEvent: (where?: ParentEventWhereInput) => Promise<boolean>;
  parentNote: (where?: ParentNoteWhereInput) => Promise<boolean>;
  studio: (where?: StudioWhereInput) => Promise<boolean>;
  studioEvent: (where?: StudioEventWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  accessRequest: (
    where: AccessRequestWhereUniqueInput
  ) => AccessRequestNullablePromise;
  accessRequests: (args?: {
    where?: AccessRequestWhereInput;
    orderBy?: AccessRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AccessRequest>;
  accessRequestsConnection: (args?: {
    where?: AccessRequestWhereInput;
    orderBy?: AccessRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AccessRequestConnectionPromise;
  customRoutine: (
    where: CustomRoutineWhereUniqueInput
  ) => CustomRoutineNullablePromise;
  customRoutines: (args?: {
    where?: CustomRoutineWhereInput;
    orderBy?: CustomRoutineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CustomRoutine>;
  customRoutinesConnection: (args?: {
    where?: CustomRoutineWhereInput;
    orderBy?: CustomRoutineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomRoutineConnectionPromise;
  danceClass: (where: DanceClassWhereUniqueInput) => DanceClassNullablePromise;
  danceClasses: (args?: {
    where?: DanceClassWhereInput;
    orderBy?: DanceClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DanceClass>;
  danceClassesConnection: (args?: {
    where?: DanceClassWhereInput;
    orderBy?: DanceClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DanceClassConnectionPromise;
  dancer: (where: DancerWhereUniqueInput) => DancerNullablePromise;
  dancers: (args?: {
    where?: DancerWhereInput;
    orderBy?: DancerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Dancer>;
  dancersConnection: (args?: {
    where?: DancerWhereInput;
    orderBy?: DancerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DancerConnectionPromise;
  enrollmentRequest: (
    where: EnrollmentRequestWhereUniqueInput
  ) => EnrollmentRequestNullablePromise;
  enrollmentRequests: (args?: {
    where?: EnrollmentRequestWhereInput;
    orderBy?: EnrollmentRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EnrollmentRequest>;
  enrollmentRequestsConnection: (args?: {
    where?: EnrollmentRequestWhereInput;
    orderBy?: EnrollmentRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EnrollmentRequestConnectionPromise;
  hairStyle: (where: HairStyleWhereUniqueInput) => HairStyleNullablePromise;
  hairStyles: (args?: {
    where?: HairStyleWhereInput;
    orderBy?: HairStyleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<HairStyle>;
  hairStylesConnection: (args?: {
    where?: HairStyleWhereInput;
    orderBy?: HairStyleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HairStyleConnectionPromise;
  makeupSet: (where: MakeupSetWhereUniqueInput) => MakeupSetNullablePromise;
  makeupSets: (args?: {
    where?: MakeupSetWhereInput;
    orderBy?: MakeupSetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MakeupSet>;
  makeupSetsConnection: (args?: {
    where?: MakeupSetWhereInput;
    orderBy?: MakeupSetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MakeupSetConnectionPromise;
  parent: (where: ParentWhereUniqueInput) => ParentNullablePromise;
  parents: (args?: {
    where?: ParentWhereInput;
    orderBy?: ParentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Parent>;
  parentsConnection: (args?: {
    where?: ParentWhereInput;
    orderBy?: ParentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ParentConnectionPromise;
  parentEvent: (
    where: ParentEventWhereUniqueInput
  ) => ParentEventNullablePromise;
  parentEvents: (args?: {
    where?: ParentEventWhereInput;
    orderBy?: ParentEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ParentEvent>;
  parentEventsConnection: (args?: {
    where?: ParentEventWhereInput;
    orderBy?: ParentEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ParentEventConnectionPromise;
  parentNote: (where: ParentNoteWhereUniqueInput) => ParentNoteNullablePromise;
  parentNotes: (args?: {
    where?: ParentNoteWhereInput;
    orderBy?: ParentNoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ParentNote>;
  parentNotesConnection: (args?: {
    where?: ParentNoteWhereInput;
    orderBy?: ParentNoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ParentNoteConnectionPromise;
  studio: (where: StudioWhereUniqueInput) => StudioNullablePromise;
  studios: (args?: {
    where?: StudioWhereInput;
    orderBy?: StudioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Studio>;
  studiosConnection: (args?: {
    where?: StudioWhereInput;
    orderBy?: StudioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudioConnectionPromise;
  studioEvent: (
    where: StudioEventWhereUniqueInput
  ) => StudioEventNullablePromise;
  studioEvents: (args?: {
    where?: StudioEventWhereInput;
    orderBy?: StudioEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<StudioEvent>;
  studioEventsConnection: (args?: {
    where?: StudioEventWhereInput;
    orderBy?: StudioEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudioEventConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAccessRequest: (data: AccessRequestCreateInput) => AccessRequestPromise;
  updateAccessRequest: (args: {
    data: AccessRequestUpdateInput;
    where: AccessRequestWhereUniqueInput;
  }) => AccessRequestPromise;
  upsertAccessRequest: (args: {
    where: AccessRequestWhereUniqueInput;
    create: AccessRequestCreateInput;
    update: AccessRequestUpdateInput;
  }) => AccessRequestPromise;
  deleteAccessRequest: (
    where: AccessRequestWhereUniqueInput
  ) => AccessRequestPromise;
  deleteManyAccessRequests: (
    where?: AccessRequestWhereInput
  ) => BatchPayloadPromise;
  createCustomRoutine: (data: CustomRoutineCreateInput) => CustomRoutinePromise;
  updateCustomRoutine: (args: {
    data: CustomRoutineUpdateInput;
    where: CustomRoutineWhereUniqueInput;
  }) => CustomRoutinePromise;
  updateManyCustomRoutines: (args: {
    data: CustomRoutineUpdateManyMutationInput;
    where?: CustomRoutineWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomRoutine: (args: {
    where: CustomRoutineWhereUniqueInput;
    create: CustomRoutineCreateInput;
    update: CustomRoutineUpdateInput;
  }) => CustomRoutinePromise;
  deleteCustomRoutine: (
    where: CustomRoutineWhereUniqueInput
  ) => CustomRoutinePromise;
  deleteManyCustomRoutines: (
    where?: CustomRoutineWhereInput
  ) => BatchPayloadPromise;
  createDanceClass: (data: DanceClassCreateInput) => DanceClassPromise;
  updateDanceClass: (args: {
    data: DanceClassUpdateInput;
    where: DanceClassWhereUniqueInput;
  }) => DanceClassPromise;
  updateManyDanceClasses: (args: {
    data: DanceClassUpdateManyMutationInput;
    where?: DanceClassWhereInput;
  }) => BatchPayloadPromise;
  upsertDanceClass: (args: {
    where: DanceClassWhereUniqueInput;
    create: DanceClassCreateInput;
    update: DanceClassUpdateInput;
  }) => DanceClassPromise;
  deleteDanceClass: (where: DanceClassWhereUniqueInput) => DanceClassPromise;
  deleteManyDanceClasses: (where?: DanceClassWhereInput) => BatchPayloadPromise;
  createDancer: (data: DancerCreateInput) => DancerPromise;
  updateDancer: (args: {
    data: DancerUpdateInput;
    where: DancerWhereUniqueInput;
  }) => DancerPromise;
  updateManyDancers: (args: {
    data: DancerUpdateManyMutationInput;
    where?: DancerWhereInput;
  }) => BatchPayloadPromise;
  upsertDancer: (args: {
    where: DancerWhereUniqueInput;
    create: DancerCreateInput;
    update: DancerUpdateInput;
  }) => DancerPromise;
  deleteDancer: (where: DancerWhereUniqueInput) => DancerPromise;
  deleteManyDancers: (where?: DancerWhereInput) => BatchPayloadPromise;
  createEnrollmentRequest: (
    data: EnrollmentRequestCreateInput
  ) => EnrollmentRequestPromise;
  updateEnrollmentRequest: (args: {
    data: EnrollmentRequestUpdateInput;
    where: EnrollmentRequestWhereUniqueInput;
  }) => EnrollmentRequestPromise;
  upsertEnrollmentRequest: (args: {
    where: EnrollmentRequestWhereUniqueInput;
    create: EnrollmentRequestCreateInput;
    update: EnrollmentRequestUpdateInput;
  }) => EnrollmentRequestPromise;
  deleteEnrollmentRequest: (
    where: EnrollmentRequestWhereUniqueInput
  ) => EnrollmentRequestPromise;
  deleteManyEnrollmentRequests: (
    where?: EnrollmentRequestWhereInput
  ) => BatchPayloadPromise;
  createHairStyle: (data: HairStyleCreateInput) => HairStylePromise;
  updateHairStyle: (args: {
    data: HairStyleUpdateInput;
    where: HairStyleWhereUniqueInput;
  }) => HairStylePromise;
  updateManyHairStyles: (args: {
    data: HairStyleUpdateManyMutationInput;
    where?: HairStyleWhereInput;
  }) => BatchPayloadPromise;
  upsertHairStyle: (args: {
    where: HairStyleWhereUniqueInput;
    create: HairStyleCreateInput;
    update: HairStyleUpdateInput;
  }) => HairStylePromise;
  deleteHairStyle: (where: HairStyleWhereUniqueInput) => HairStylePromise;
  deleteManyHairStyles: (where?: HairStyleWhereInput) => BatchPayloadPromise;
  createMakeupSet: (data: MakeupSetCreateInput) => MakeupSetPromise;
  updateMakeupSet: (args: {
    data: MakeupSetUpdateInput;
    where: MakeupSetWhereUniqueInput;
  }) => MakeupSetPromise;
  updateManyMakeupSets: (args: {
    data: MakeupSetUpdateManyMutationInput;
    where?: MakeupSetWhereInput;
  }) => BatchPayloadPromise;
  upsertMakeupSet: (args: {
    where: MakeupSetWhereUniqueInput;
    create: MakeupSetCreateInput;
    update: MakeupSetUpdateInput;
  }) => MakeupSetPromise;
  deleteMakeupSet: (where: MakeupSetWhereUniqueInput) => MakeupSetPromise;
  deleteManyMakeupSets: (where?: MakeupSetWhereInput) => BatchPayloadPromise;
  createParent: (data: ParentCreateInput) => ParentPromise;
  updateParent: (args: {
    data: ParentUpdateInput;
    where: ParentWhereUniqueInput;
  }) => ParentPromise;
  updateManyParents: (args: {
    data: ParentUpdateManyMutationInput;
    where?: ParentWhereInput;
  }) => BatchPayloadPromise;
  upsertParent: (args: {
    where: ParentWhereUniqueInput;
    create: ParentCreateInput;
    update: ParentUpdateInput;
  }) => ParentPromise;
  deleteParent: (where: ParentWhereUniqueInput) => ParentPromise;
  deleteManyParents: (where?: ParentWhereInput) => BatchPayloadPromise;
  createParentEvent: (data: ParentEventCreateInput) => ParentEventPromise;
  updateParentEvent: (args: {
    data: ParentEventUpdateInput;
    where: ParentEventWhereUniqueInput;
  }) => ParentEventPromise;
  updateManyParentEvents: (args: {
    data: ParentEventUpdateManyMutationInput;
    where?: ParentEventWhereInput;
  }) => BatchPayloadPromise;
  upsertParentEvent: (args: {
    where: ParentEventWhereUniqueInput;
    create: ParentEventCreateInput;
    update: ParentEventUpdateInput;
  }) => ParentEventPromise;
  deleteParentEvent: (where: ParentEventWhereUniqueInput) => ParentEventPromise;
  deleteManyParentEvents: (
    where?: ParentEventWhereInput
  ) => BatchPayloadPromise;
  createParentNote: (data: ParentNoteCreateInput) => ParentNotePromise;
  updateParentNote: (args: {
    data: ParentNoteUpdateInput;
    where: ParentNoteWhereUniqueInput;
  }) => ParentNotePromise;
  updateManyParentNotes: (args: {
    data: ParentNoteUpdateManyMutationInput;
    where?: ParentNoteWhereInput;
  }) => BatchPayloadPromise;
  upsertParentNote: (args: {
    where: ParentNoteWhereUniqueInput;
    create: ParentNoteCreateInput;
    update: ParentNoteUpdateInput;
  }) => ParentNotePromise;
  deleteParentNote: (where: ParentNoteWhereUniqueInput) => ParentNotePromise;
  deleteManyParentNotes: (where?: ParentNoteWhereInput) => BatchPayloadPromise;
  createStudio: (data: StudioCreateInput) => StudioPromise;
  updateStudio: (args: {
    data: StudioUpdateInput;
    where: StudioWhereUniqueInput;
  }) => StudioPromise;
  updateManyStudios: (args: {
    data: StudioUpdateManyMutationInput;
    where?: StudioWhereInput;
  }) => BatchPayloadPromise;
  upsertStudio: (args: {
    where: StudioWhereUniqueInput;
    create: StudioCreateInput;
    update: StudioUpdateInput;
  }) => StudioPromise;
  deleteStudio: (where: StudioWhereUniqueInput) => StudioPromise;
  deleteManyStudios: (where?: StudioWhereInput) => BatchPayloadPromise;
  createStudioEvent: (data: StudioEventCreateInput) => StudioEventPromise;
  updateStudioEvent: (args: {
    data: StudioEventUpdateInput;
    where: StudioEventWhereUniqueInput;
  }) => StudioEventPromise;
  updateManyStudioEvents: (args: {
    data: StudioEventUpdateManyMutationInput;
    where?: StudioEventWhereInput;
  }) => BatchPayloadPromise;
  upsertStudioEvent: (args: {
    where: StudioEventWhereUniqueInput;
    create: StudioEventCreateInput;
    update: StudioEventUpdateInput;
  }) => StudioEventPromise;
  deleteStudioEvent: (where: StudioEventWhereUniqueInput) => StudioEventPromise;
  deleteManyStudioEvents: (
    where?: StudioEventWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  accessRequest: (
    where?: AccessRequestSubscriptionWhereInput
  ) => AccessRequestSubscriptionPayloadSubscription;
  customRoutine: (
    where?: CustomRoutineSubscriptionWhereInput
  ) => CustomRoutineSubscriptionPayloadSubscription;
  danceClass: (
    where?: DanceClassSubscriptionWhereInput
  ) => DanceClassSubscriptionPayloadSubscription;
  dancer: (
    where?: DancerSubscriptionWhereInput
  ) => DancerSubscriptionPayloadSubscription;
  enrollmentRequest: (
    where?: EnrollmentRequestSubscriptionWhereInput
  ) => EnrollmentRequestSubscriptionPayloadSubscription;
  hairStyle: (
    where?: HairStyleSubscriptionWhereInput
  ) => HairStyleSubscriptionPayloadSubscription;
  makeupSet: (
    where?: MakeupSetSubscriptionWhereInput
  ) => MakeupSetSubscriptionPayloadSubscription;
  parent: (
    where?: ParentSubscriptionWhereInput
  ) => ParentSubscriptionPayloadSubscription;
  parentEvent: (
    where?: ParentEventSubscriptionWhereInput
  ) => ParentEventSubscriptionPayloadSubscription;
  parentNote: (
    where?: ParentNoteSubscriptionWhereInput
  ) => ParentNoteSubscriptionPayloadSubscription;
  studio: (
    where?: StudioSubscriptionWhereInput
  ) => StudioSubscriptionPayloadSubscription;
  studioEvent: (
    where?: StudioEventSubscriptionWhereInput
  ) => StudioEventSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type DanceClassOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "music_ASC"
  | "music_DESC"
  | "musicId_ASC"
  | "musicId_DESC"
  | "performanceName_ASC"
  | "performanceName_DESC"
  | "day_ASC"
  | "day_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "competitiveLevel_ASC"
  | "competitiveLevel_DESC"
  | "ageDivision_ASC"
  | "ageDivision_DESC"
  | "style_ASC"
  | "style_DESC"
  | "tights_ASC"
  | "tights_DESC"
  | "shoes_ASC"
  | "shoes_DESC"
  | "notes_ASC"
  | "notes_DESC"
  | "size_ASC"
  | "size_DESC"
  | "custom_ASC"
  | "custom_DESC"
  | "entryNumber_ASC"
  | "entryNumber_DESC"
  | "entryTime_ASC"
  | "entryTime_DESC"
  | "entryDay_ASC"
  | "entryDay_DESC"
  | "videoUrl_ASC"
  | "videoUrl_DESC"
  | "videoId_ASC"
  | "videoId_DESC";

export type DancerOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "avatarId_ASC"
  | "avatarId_DESC"
  | "lastName_ASC"
  | "lastName_DESC";

export type CustomRoutineOrderByInput =
  | "custom_ASC"
  | "custom_DESC"
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "music_ASC"
  | "music_DESC"
  | "musicId_ASC"
  | "musicId_DESC"
  | "style_ASC"
  | "style_DESC"
  | "competitiveLevel_ASC"
  | "competitiveLevel_DESC"
  | "ageDivision_ASC"
  | "ageDivision_DESC"
  | "performanceName_ASC"
  | "performanceName_DESC"
  | "day_ASC"
  | "day_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "shoes_ASC"
  | "shoes_DESC"
  | "tights_ASC"
  | "tights_DESC"
  | "notes_ASC"
  | "notes_DESC"
  | "type_ASC"
  | "type_DESC"
  | "entryNumber_ASC"
  | "entryNumber_DESC"
  | "entryTime_ASC"
  | "entryTime_DESC"
  | "entryDay_ASC"
  | "entryDay_DESC";

export type StudioOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "studioName_ASC"
  | "studioName_DESC"
  | "userType_ASC"
  | "userType_DESC"
  | "password_ASC"
  | "password_DESC"
  | "resetToken_ASC"
  | "resetToken_DESC"
  | "resetTokenExpiry_ASC"
  | "resetTokenExpiry_DESC"
  | "website_ASC"
  | "website_DESC"
  | "agreeToTerms_ASC"
  | "agreeToTerms_DESC"
  | "readPrivacy_ASC"
  | "readPrivacy_DESC";

export type MakeupSetOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "lipstick_ASC"
  | "lipstick_DESC"
  | "eyeShadow_ASC"
  | "eyeShadow_DESC"
  | "eyeLids_ASC"
  | "eyeLids_DESC"
  | "eyeCrease_ASC"
  | "eyeCrease_DESC"
  | "eyeLiner_ASC"
  | "eyeLiner_DESC"
  | "eyelashes_ASC"
  | "eyelashes_DESC"
  | "foundation_ASC"
  | "foundation_DESC"
  | "powder_ASC"
  | "powder_DESC"
  | "blush_ASC"
  | "blush_DESC"
  | "bronzer_ASC"
  | "bronzer_DESC"
  | "applyToCategories_ASC"
  | "applyToCategories_DESC"
  | "notes_ASC"
  | "notes_DESC";

export type HairStyleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "image_ASC"
  | "image_DESC"
  | "link_ASC"
  | "link_DESC";

export type StudioEventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "type_ASC"
  | "type_DESC"
  | "beginDate_ASC"
  | "beginDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "location_ASC"
  | "location_DESC"
  | "address1_ASC"
  | "address1_DESC"
  | "address2_ASC"
  | "address2_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "url_ASC"
  | "url_DESC"
  | "notes_ASC"
  | "notes_DESC";

export type EnrollmentRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type AccessRequestOrderByInput = "id_ASC" | "id_DESC";

export type ParentOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "userType_ASC"
  | "userType_DESC"
  | "password_ASC"
  | "password_DESC"
  | "resetToken_ASC"
  | "resetToken_DESC"
  | "resetTokenExpiry_ASC"
  | "resetTokenExpiry_DESC"
  | "agreeToTerms_ASC"
  | "agreeToTerms_DESC"
  | "readPrivacy_ASC"
  | "readPrivacy_DESC";

export type ParentEventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "type_ASC"
  | "type_DESC"
  | "beginDate_ASC"
  | "beginDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "location_ASC"
  | "location_DESC"
  | "address1_ASC"
  | "address1_DESC"
  | "address2_ASC"
  | "address2_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "url_ASC"
  | "url_DESC"
  | "notes_ASC"
  | "notes_DESC";

export type ParentNoteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "note_ASC"
  | "note_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AccessRequestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DanceClassWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  studio?: Maybe<StudioWhereInput>;
  music?: Maybe<String>;
  music_not?: Maybe<String>;
  music_in?: Maybe<String[] | String>;
  music_not_in?: Maybe<String[] | String>;
  music_lt?: Maybe<String>;
  music_lte?: Maybe<String>;
  music_gt?: Maybe<String>;
  music_gte?: Maybe<String>;
  music_contains?: Maybe<String>;
  music_not_contains?: Maybe<String>;
  music_starts_with?: Maybe<String>;
  music_not_starts_with?: Maybe<String>;
  music_ends_with?: Maybe<String>;
  music_not_ends_with?: Maybe<String>;
  musicId?: Maybe<String>;
  musicId_not?: Maybe<String>;
  musicId_in?: Maybe<String[] | String>;
  musicId_not_in?: Maybe<String[] | String>;
  musicId_lt?: Maybe<String>;
  musicId_lte?: Maybe<String>;
  musicId_gt?: Maybe<String>;
  musicId_gte?: Maybe<String>;
  musicId_contains?: Maybe<String>;
  musicId_not_contains?: Maybe<String>;
  musicId_starts_with?: Maybe<String>;
  musicId_not_starts_with?: Maybe<String>;
  musicId_ends_with?: Maybe<String>;
  musicId_not_ends_with?: Maybe<String>;
  performanceName?: Maybe<String>;
  performanceName_not?: Maybe<String>;
  performanceName_in?: Maybe<String[] | String>;
  performanceName_not_in?: Maybe<String[] | String>;
  performanceName_lt?: Maybe<String>;
  performanceName_lte?: Maybe<String>;
  performanceName_gt?: Maybe<String>;
  performanceName_gte?: Maybe<String>;
  performanceName_contains?: Maybe<String>;
  performanceName_not_contains?: Maybe<String>;
  performanceName_starts_with?: Maybe<String>;
  performanceName_not_starts_with?: Maybe<String>;
  performanceName_ends_with?: Maybe<String>;
  performanceName_not_ends_with?: Maybe<String>;
  day?: Maybe<String>;
  day_not?: Maybe<String>;
  day_in?: Maybe<String[] | String>;
  day_not_in?: Maybe<String[] | String>;
  day_lt?: Maybe<String>;
  day_lte?: Maybe<String>;
  day_gt?: Maybe<String>;
  day_gte?: Maybe<String>;
  day_contains?: Maybe<String>;
  day_not_contains?: Maybe<String>;
  day_starts_with?: Maybe<String>;
  day_not_starts_with?: Maybe<String>;
  day_ends_with?: Maybe<String>;
  day_not_ends_with?: Maybe<String>;
  startTime?: Maybe<String>;
  startTime_not?: Maybe<String>;
  startTime_in?: Maybe<String[] | String>;
  startTime_not_in?: Maybe<String[] | String>;
  startTime_lt?: Maybe<String>;
  startTime_lte?: Maybe<String>;
  startTime_gt?: Maybe<String>;
  startTime_gte?: Maybe<String>;
  startTime_contains?: Maybe<String>;
  startTime_not_contains?: Maybe<String>;
  startTime_starts_with?: Maybe<String>;
  startTime_not_starts_with?: Maybe<String>;
  startTime_ends_with?: Maybe<String>;
  startTime_not_ends_with?: Maybe<String>;
  endTime?: Maybe<String>;
  endTime_not?: Maybe<String>;
  endTime_in?: Maybe<String[] | String>;
  endTime_not_in?: Maybe<String[] | String>;
  endTime_lt?: Maybe<String>;
  endTime_lte?: Maybe<String>;
  endTime_gt?: Maybe<String>;
  endTime_gte?: Maybe<String>;
  endTime_contains?: Maybe<String>;
  endTime_not_contains?: Maybe<String>;
  endTime_starts_with?: Maybe<String>;
  endTime_not_starts_with?: Maybe<String>;
  endTime_ends_with?: Maybe<String>;
  endTime_not_ends_with?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  competitiveLevel_not?: Maybe<String>;
  competitiveLevel_in?: Maybe<String[] | String>;
  competitiveLevel_not_in?: Maybe<String[] | String>;
  competitiveLevel_lt?: Maybe<String>;
  competitiveLevel_lte?: Maybe<String>;
  competitiveLevel_gt?: Maybe<String>;
  competitiveLevel_gte?: Maybe<String>;
  competitiveLevel_contains?: Maybe<String>;
  competitiveLevel_not_contains?: Maybe<String>;
  competitiveLevel_starts_with?: Maybe<String>;
  competitiveLevel_not_starts_with?: Maybe<String>;
  competitiveLevel_ends_with?: Maybe<String>;
  competitiveLevel_not_ends_with?: Maybe<String>;
  ageDivision?: Maybe<String>;
  ageDivision_not?: Maybe<String>;
  ageDivision_in?: Maybe<String[] | String>;
  ageDivision_not_in?: Maybe<String[] | String>;
  ageDivision_lt?: Maybe<String>;
  ageDivision_lte?: Maybe<String>;
  ageDivision_gt?: Maybe<String>;
  ageDivision_gte?: Maybe<String>;
  ageDivision_contains?: Maybe<String>;
  ageDivision_not_contains?: Maybe<String>;
  ageDivision_starts_with?: Maybe<String>;
  ageDivision_not_starts_with?: Maybe<String>;
  ageDivision_ends_with?: Maybe<String>;
  ageDivision_not_ends_with?: Maybe<String>;
  style?: Maybe<String>;
  style_not?: Maybe<String>;
  style_in?: Maybe<String[] | String>;
  style_not_in?: Maybe<String[] | String>;
  style_lt?: Maybe<String>;
  style_lte?: Maybe<String>;
  style_gt?: Maybe<String>;
  style_gte?: Maybe<String>;
  style_contains?: Maybe<String>;
  style_not_contains?: Maybe<String>;
  style_starts_with?: Maybe<String>;
  style_not_starts_with?: Maybe<String>;
  style_ends_with?: Maybe<String>;
  style_not_ends_with?: Maybe<String>;
  tights?: Maybe<String>;
  tights_not?: Maybe<String>;
  tights_in?: Maybe<String[] | String>;
  tights_not_in?: Maybe<String[] | String>;
  tights_lt?: Maybe<String>;
  tights_lte?: Maybe<String>;
  tights_gt?: Maybe<String>;
  tights_gte?: Maybe<String>;
  tights_contains?: Maybe<String>;
  tights_not_contains?: Maybe<String>;
  tights_starts_with?: Maybe<String>;
  tights_not_starts_with?: Maybe<String>;
  tights_ends_with?: Maybe<String>;
  tights_not_ends_with?: Maybe<String>;
  shoes?: Maybe<String>;
  shoes_not?: Maybe<String>;
  shoes_in?: Maybe<String[] | String>;
  shoes_not_in?: Maybe<String[] | String>;
  shoes_lt?: Maybe<String>;
  shoes_lte?: Maybe<String>;
  shoes_gt?: Maybe<String>;
  shoes_gte?: Maybe<String>;
  shoes_contains?: Maybe<String>;
  shoes_not_contains?: Maybe<String>;
  shoes_starts_with?: Maybe<String>;
  shoes_not_starts_with?: Maybe<String>;
  shoes_ends_with?: Maybe<String>;
  shoes_not_ends_with?: Maybe<String>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  dancers_every?: Maybe<DancerWhereInput>;
  dancers_some?: Maybe<DancerWhereInput>;
  dancers_none?: Maybe<DancerWhereInput>;
  makeupSet?: Maybe<MakeupSetWhereInput>;
  size?: Maybe<String>;
  size_not?: Maybe<String>;
  size_in?: Maybe<String[] | String>;
  size_not_in?: Maybe<String[] | String>;
  size_lt?: Maybe<String>;
  size_lte?: Maybe<String>;
  size_gt?: Maybe<String>;
  size_gte?: Maybe<String>;
  size_contains?: Maybe<String>;
  size_not_contains?: Maybe<String>;
  size_starts_with?: Maybe<String>;
  size_not_starts_with?: Maybe<String>;
  size_ends_with?: Maybe<String>;
  size_not_ends_with?: Maybe<String>;
  custom?: Maybe<Boolean>;
  custom_not?: Maybe<Boolean>;
  entryNumber?: Maybe<String>;
  entryNumber_not?: Maybe<String>;
  entryNumber_in?: Maybe<String[] | String>;
  entryNumber_not_in?: Maybe<String[] | String>;
  entryNumber_lt?: Maybe<String>;
  entryNumber_lte?: Maybe<String>;
  entryNumber_gt?: Maybe<String>;
  entryNumber_gte?: Maybe<String>;
  entryNumber_contains?: Maybe<String>;
  entryNumber_not_contains?: Maybe<String>;
  entryNumber_starts_with?: Maybe<String>;
  entryNumber_not_starts_with?: Maybe<String>;
  entryNumber_ends_with?: Maybe<String>;
  entryNumber_not_ends_with?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryTime_not?: Maybe<String>;
  entryTime_in?: Maybe<String[] | String>;
  entryTime_not_in?: Maybe<String[] | String>;
  entryTime_lt?: Maybe<String>;
  entryTime_lte?: Maybe<String>;
  entryTime_gt?: Maybe<String>;
  entryTime_gte?: Maybe<String>;
  entryTime_contains?: Maybe<String>;
  entryTime_not_contains?: Maybe<String>;
  entryTime_starts_with?: Maybe<String>;
  entryTime_not_starts_with?: Maybe<String>;
  entryTime_ends_with?: Maybe<String>;
  entryTime_not_ends_with?: Maybe<String>;
  entryDay?: Maybe<String>;
  entryDay_not?: Maybe<String>;
  entryDay_in?: Maybe<String[] | String>;
  entryDay_not_in?: Maybe<String[] | String>;
  entryDay_lt?: Maybe<String>;
  entryDay_lte?: Maybe<String>;
  entryDay_gt?: Maybe<String>;
  entryDay_gte?: Maybe<String>;
  entryDay_contains?: Maybe<String>;
  entryDay_not_contains?: Maybe<String>;
  entryDay_starts_with?: Maybe<String>;
  entryDay_not_starts_with?: Maybe<String>;
  entryDay_ends_with?: Maybe<String>;
  entryDay_not_ends_with?: Maybe<String>;
  videoUrl?: Maybe<String>;
  videoUrl_not?: Maybe<String>;
  videoUrl_in?: Maybe<String[] | String>;
  videoUrl_not_in?: Maybe<String[] | String>;
  videoUrl_lt?: Maybe<String>;
  videoUrl_lte?: Maybe<String>;
  videoUrl_gt?: Maybe<String>;
  videoUrl_gte?: Maybe<String>;
  videoUrl_contains?: Maybe<String>;
  videoUrl_not_contains?: Maybe<String>;
  videoUrl_starts_with?: Maybe<String>;
  videoUrl_not_starts_with?: Maybe<String>;
  videoUrl_ends_with?: Maybe<String>;
  videoUrl_not_ends_with?: Maybe<String>;
  videoId?: Maybe<String>;
  videoId_not?: Maybe<String>;
  videoId_in?: Maybe<String[] | String>;
  videoId_not_in?: Maybe<String[] | String>;
  videoId_lt?: Maybe<String>;
  videoId_lte?: Maybe<String>;
  videoId_gt?: Maybe<String>;
  videoId_gte?: Maybe<String>;
  videoId_contains?: Maybe<String>;
  videoId_not_contains?: Maybe<String>;
  videoId_starts_with?: Maybe<String>;
  videoId_not_starts_with?: Maybe<String>;
  videoId_ends_with?: Maybe<String>;
  videoId_not_ends_with?: Maybe<String>;
  AND?: Maybe<DanceClassWhereInput[] | DanceClassWhereInput>;
  OR?: Maybe<DanceClassWhereInput[] | DanceClassWhereInput>;
  NOT?: Maybe<DanceClassWhereInput[] | DanceClassWhereInput>;
}

export interface StudioWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  studioName?: Maybe<String>;
  studioName_not?: Maybe<String>;
  studioName_in?: Maybe<String[] | String>;
  studioName_not_in?: Maybe<String[] | String>;
  studioName_lt?: Maybe<String>;
  studioName_lte?: Maybe<String>;
  studioName_gt?: Maybe<String>;
  studioName_gte?: Maybe<String>;
  studioName_contains?: Maybe<String>;
  studioName_not_contains?: Maybe<String>;
  studioName_starts_with?: Maybe<String>;
  studioName_not_starts_with?: Maybe<String>;
  studioName_ends_with?: Maybe<String>;
  studioName_not_ends_with?: Maybe<String>;
  userType?: Maybe<String>;
  userType_not?: Maybe<String>;
  userType_in?: Maybe<String[] | String>;
  userType_not_in?: Maybe<String[] | String>;
  userType_lt?: Maybe<String>;
  userType_lte?: Maybe<String>;
  userType_gt?: Maybe<String>;
  userType_gte?: Maybe<String>;
  userType_contains?: Maybe<String>;
  userType_not_contains?: Maybe<String>;
  userType_starts_with?: Maybe<String>;
  userType_not_starts_with?: Maybe<String>;
  userType_ends_with?: Maybe<String>;
  userType_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetToken_not?: Maybe<String>;
  resetToken_in?: Maybe<String[] | String>;
  resetToken_not_in?: Maybe<String[] | String>;
  resetToken_lt?: Maybe<String>;
  resetToken_lte?: Maybe<String>;
  resetToken_gt?: Maybe<String>;
  resetToken_gte?: Maybe<String>;
  resetToken_contains?: Maybe<String>;
  resetToken_not_contains?: Maybe<String>;
  resetToken_starts_with?: Maybe<String>;
  resetToken_not_starts_with?: Maybe<String>;
  resetToken_ends_with?: Maybe<String>;
  resetToken_not_ends_with?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  resetTokenExpiry_not?: Maybe<Float>;
  resetTokenExpiry_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_not_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_lt?: Maybe<Float>;
  resetTokenExpiry_lte?: Maybe<Float>;
  resetTokenExpiry_gt?: Maybe<Float>;
  resetTokenExpiry_gte?: Maybe<Float>;
  danceClasses_every?: Maybe<DanceClassWhereInput>;
  danceClasses_some?: Maybe<DanceClassWhereInput>;
  danceClasses_none?: Maybe<DanceClassWhereInput>;
  makeupSets_every?: Maybe<MakeupSetWhereInput>;
  makeupSets_some?: Maybe<MakeupSetWhereInput>;
  makeupSets_none?: Maybe<MakeupSetWhereInput>;
  hairStyles_every?: Maybe<HairStyleWhereInput>;
  hairStyles_some?: Maybe<HairStyleWhereInput>;
  hairStyles_none?: Maybe<HairStyleWhereInput>;
  dancers_every?: Maybe<DancerWhereInput>;
  dancers_some?: Maybe<DancerWhereInput>;
  dancers_none?: Maybe<DancerWhereInput>;
  events_every?: Maybe<StudioEventWhereInput>;
  events_some?: Maybe<StudioEventWhereInput>;
  events_none?: Maybe<StudioEventWhereInput>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  enrollmentRequests_every?: Maybe<EnrollmentRequestWhereInput>;
  enrollmentRequests_some?: Maybe<EnrollmentRequestWhereInput>;
  enrollmentRequests_none?: Maybe<EnrollmentRequestWhereInput>;
  accessRequests_every?: Maybe<AccessRequestWhereInput>;
  accessRequests_some?: Maybe<AccessRequestWhereInput>;
  accessRequests_none?: Maybe<AccessRequestWhereInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  agreeToTerms_not?: Maybe<DateTimeInput>;
  agreeToTerms_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  agreeToTerms_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  agreeToTerms_lt?: Maybe<DateTimeInput>;
  agreeToTerms_lte?: Maybe<DateTimeInput>;
  agreeToTerms_gt?: Maybe<DateTimeInput>;
  agreeToTerms_gte?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
  readPrivacy_not?: Maybe<DateTimeInput>;
  readPrivacy_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  readPrivacy_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  readPrivacy_lt?: Maybe<DateTimeInput>;
  readPrivacy_lte?: Maybe<DateTimeInput>;
  readPrivacy_gt?: Maybe<DateTimeInput>;
  readPrivacy_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StudioWhereInput[] | StudioWhereInput>;
  OR?: Maybe<StudioWhereInput[] | StudioWhereInput>;
  NOT?: Maybe<StudioWhereInput[] | StudioWhereInput>;
}

export interface MakeupSetWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  studio?: Maybe<StudioWhereInput>;
  lipstick?: Maybe<String>;
  lipstick_not?: Maybe<String>;
  lipstick_in?: Maybe<String[] | String>;
  lipstick_not_in?: Maybe<String[] | String>;
  lipstick_lt?: Maybe<String>;
  lipstick_lte?: Maybe<String>;
  lipstick_gt?: Maybe<String>;
  lipstick_gte?: Maybe<String>;
  lipstick_contains?: Maybe<String>;
  lipstick_not_contains?: Maybe<String>;
  lipstick_starts_with?: Maybe<String>;
  lipstick_not_starts_with?: Maybe<String>;
  lipstick_ends_with?: Maybe<String>;
  lipstick_not_ends_with?: Maybe<String>;
  eyeShadow?: Maybe<String>;
  eyeShadow_not?: Maybe<String>;
  eyeShadow_in?: Maybe<String[] | String>;
  eyeShadow_not_in?: Maybe<String[] | String>;
  eyeShadow_lt?: Maybe<String>;
  eyeShadow_lte?: Maybe<String>;
  eyeShadow_gt?: Maybe<String>;
  eyeShadow_gte?: Maybe<String>;
  eyeShadow_contains?: Maybe<String>;
  eyeShadow_not_contains?: Maybe<String>;
  eyeShadow_starts_with?: Maybe<String>;
  eyeShadow_not_starts_with?: Maybe<String>;
  eyeShadow_ends_with?: Maybe<String>;
  eyeShadow_not_ends_with?: Maybe<String>;
  eyeLids?: Maybe<String>;
  eyeLids_not?: Maybe<String>;
  eyeLids_in?: Maybe<String[] | String>;
  eyeLids_not_in?: Maybe<String[] | String>;
  eyeLids_lt?: Maybe<String>;
  eyeLids_lte?: Maybe<String>;
  eyeLids_gt?: Maybe<String>;
  eyeLids_gte?: Maybe<String>;
  eyeLids_contains?: Maybe<String>;
  eyeLids_not_contains?: Maybe<String>;
  eyeLids_starts_with?: Maybe<String>;
  eyeLids_not_starts_with?: Maybe<String>;
  eyeLids_ends_with?: Maybe<String>;
  eyeLids_not_ends_with?: Maybe<String>;
  eyeCrease?: Maybe<String>;
  eyeCrease_not?: Maybe<String>;
  eyeCrease_in?: Maybe<String[] | String>;
  eyeCrease_not_in?: Maybe<String[] | String>;
  eyeCrease_lt?: Maybe<String>;
  eyeCrease_lte?: Maybe<String>;
  eyeCrease_gt?: Maybe<String>;
  eyeCrease_gte?: Maybe<String>;
  eyeCrease_contains?: Maybe<String>;
  eyeCrease_not_contains?: Maybe<String>;
  eyeCrease_starts_with?: Maybe<String>;
  eyeCrease_not_starts_with?: Maybe<String>;
  eyeCrease_ends_with?: Maybe<String>;
  eyeCrease_not_ends_with?: Maybe<String>;
  eyeLiner?: Maybe<String>;
  eyeLiner_not?: Maybe<String>;
  eyeLiner_in?: Maybe<String[] | String>;
  eyeLiner_not_in?: Maybe<String[] | String>;
  eyeLiner_lt?: Maybe<String>;
  eyeLiner_lte?: Maybe<String>;
  eyeLiner_gt?: Maybe<String>;
  eyeLiner_gte?: Maybe<String>;
  eyeLiner_contains?: Maybe<String>;
  eyeLiner_not_contains?: Maybe<String>;
  eyeLiner_starts_with?: Maybe<String>;
  eyeLiner_not_starts_with?: Maybe<String>;
  eyeLiner_ends_with?: Maybe<String>;
  eyeLiner_not_ends_with?: Maybe<String>;
  eyelashes?: Maybe<String>;
  eyelashes_not?: Maybe<String>;
  eyelashes_in?: Maybe<String[] | String>;
  eyelashes_not_in?: Maybe<String[] | String>;
  eyelashes_lt?: Maybe<String>;
  eyelashes_lte?: Maybe<String>;
  eyelashes_gt?: Maybe<String>;
  eyelashes_gte?: Maybe<String>;
  eyelashes_contains?: Maybe<String>;
  eyelashes_not_contains?: Maybe<String>;
  eyelashes_starts_with?: Maybe<String>;
  eyelashes_not_starts_with?: Maybe<String>;
  eyelashes_ends_with?: Maybe<String>;
  eyelashes_not_ends_with?: Maybe<String>;
  foundation?: Maybe<String>;
  foundation_not?: Maybe<String>;
  foundation_in?: Maybe<String[] | String>;
  foundation_not_in?: Maybe<String[] | String>;
  foundation_lt?: Maybe<String>;
  foundation_lte?: Maybe<String>;
  foundation_gt?: Maybe<String>;
  foundation_gte?: Maybe<String>;
  foundation_contains?: Maybe<String>;
  foundation_not_contains?: Maybe<String>;
  foundation_starts_with?: Maybe<String>;
  foundation_not_starts_with?: Maybe<String>;
  foundation_ends_with?: Maybe<String>;
  foundation_not_ends_with?: Maybe<String>;
  powder?: Maybe<String>;
  powder_not?: Maybe<String>;
  powder_in?: Maybe<String[] | String>;
  powder_not_in?: Maybe<String[] | String>;
  powder_lt?: Maybe<String>;
  powder_lte?: Maybe<String>;
  powder_gt?: Maybe<String>;
  powder_gte?: Maybe<String>;
  powder_contains?: Maybe<String>;
  powder_not_contains?: Maybe<String>;
  powder_starts_with?: Maybe<String>;
  powder_not_starts_with?: Maybe<String>;
  powder_ends_with?: Maybe<String>;
  powder_not_ends_with?: Maybe<String>;
  blush?: Maybe<String>;
  blush_not?: Maybe<String>;
  blush_in?: Maybe<String[] | String>;
  blush_not_in?: Maybe<String[] | String>;
  blush_lt?: Maybe<String>;
  blush_lte?: Maybe<String>;
  blush_gt?: Maybe<String>;
  blush_gte?: Maybe<String>;
  blush_contains?: Maybe<String>;
  blush_not_contains?: Maybe<String>;
  blush_starts_with?: Maybe<String>;
  blush_not_starts_with?: Maybe<String>;
  blush_ends_with?: Maybe<String>;
  blush_not_ends_with?: Maybe<String>;
  bronzer?: Maybe<String>;
  bronzer_not?: Maybe<String>;
  bronzer_in?: Maybe<String[] | String>;
  bronzer_not_in?: Maybe<String[] | String>;
  bronzer_lt?: Maybe<String>;
  bronzer_lte?: Maybe<String>;
  bronzer_gt?: Maybe<String>;
  bronzer_gte?: Maybe<String>;
  bronzer_contains?: Maybe<String>;
  bronzer_not_contains?: Maybe<String>;
  bronzer_starts_with?: Maybe<String>;
  bronzer_not_starts_with?: Maybe<String>;
  bronzer_ends_with?: Maybe<String>;
  bronzer_not_ends_with?: Maybe<String>;
  applyToCategories?: Maybe<String>;
  applyToCategories_not?: Maybe<String>;
  applyToCategories_in?: Maybe<String[] | String>;
  applyToCategories_not_in?: Maybe<String[] | String>;
  applyToCategories_lt?: Maybe<String>;
  applyToCategories_lte?: Maybe<String>;
  applyToCategories_gt?: Maybe<String>;
  applyToCategories_gte?: Maybe<String>;
  applyToCategories_contains?: Maybe<String>;
  applyToCategories_not_contains?: Maybe<String>;
  applyToCategories_starts_with?: Maybe<String>;
  applyToCategories_not_starts_with?: Maybe<String>;
  applyToCategories_ends_with?: Maybe<String>;
  applyToCategories_not_ends_with?: Maybe<String>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  danceClasses_every?: Maybe<DanceClassWhereInput>;
  danceClasses_some?: Maybe<DanceClassWhereInput>;
  danceClasses_none?: Maybe<DanceClassWhereInput>;
  AND?: Maybe<MakeupSetWhereInput[] | MakeupSetWhereInput>;
  OR?: Maybe<MakeupSetWhereInput[] | MakeupSetWhereInput>;
  NOT?: Maybe<MakeupSetWhereInput[] | MakeupSetWhereInput>;
}

export interface HairStyleWhereInput {
  studio?: Maybe<StudioWhereInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  AND?: Maybe<HairStyleWhereInput[] | HairStyleWhereInput>;
  OR?: Maybe<HairStyleWhereInput[] | HairStyleWhereInput>;
  NOT?: Maybe<HairStyleWhereInput[] | HairStyleWhereInput>;
}

export interface DancerWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  parent?: Maybe<ParentWhereInput>;
  requests?: Maybe<EnrollmentRequestWhereInput>;
  danceClasses_every?: Maybe<DanceClassWhereInput>;
  danceClasses_some?: Maybe<DanceClassWhereInput>;
  danceClasses_none?: Maybe<DanceClassWhereInput>;
  customRoutines_every?: Maybe<CustomRoutineWhereInput>;
  customRoutines_some?: Maybe<CustomRoutineWhereInput>;
  customRoutines_none?: Maybe<CustomRoutineWhereInput>;
  avatar?: Maybe<String>;
  avatar_not?: Maybe<String>;
  avatar_in?: Maybe<String[] | String>;
  avatar_not_in?: Maybe<String[] | String>;
  avatar_lt?: Maybe<String>;
  avatar_lte?: Maybe<String>;
  avatar_gt?: Maybe<String>;
  avatar_gte?: Maybe<String>;
  avatar_contains?: Maybe<String>;
  avatar_not_contains?: Maybe<String>;
  avatar_starts_with?: Maybe<String>;
  avatar_not_starts_with?: Maybe<String>;
  avatar_ends_with?: Maybe<String>;
  avatar_not_ends_with?: Maybe<String>;
  avatarId?: Maybe<String>;
  avatarId_not?: Maybe<String>;
  avatarId_in?: Maybe<String[] | String>;
  avatarId_not_in?: Maybe<String[] | String>;
  avatarId_lt?: Maybe<String>;
  avatarId_lte?: Maybe<String>;
  avatarId_gt?: Maybe<String>;
  avatarId_gte?: Maybe<String>;
  avatarId_contains?: Maybe<String>;
  avatarId_not_contains?: Maybe<String>;
  avatarId_starts_with?: Maybe<String>;
  avatarId_not_starts_with?: Maybe<String>;
  avatarId_ends_with?: Maybe<String>;
  avatarId_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  studios_every?: Maybe<StudioWhereInput>;
  studios_some?: Maybe<StudioWhereInput>;
  studios_none?: Maybe<StudioWhereInput>;
  AND?: Maybe<DancerWhereInput[] | DancerWhereInput>;
  OR?: Maybe<DancerWhereInput[] | DancerWhereInput>;
  NOT?: Maybe<DancerWhereInput[] | DancerWhereInput>;
}

export interface ParentWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  userType?: Maybe<String>;
  userType_not?: Maybe<String>;
  userType_in?: Maybe<String[] | String>;
  userType_not_in?: Maybe<String[] | String>;
  userType_lt?: Maybe<String>;
  userType_lte?: Maybe<String>;
  userType_gt?: Maybe<String>;
  userType_gte?: Maybe<String>;
  userType_contains?: Maybe<String>;
  userType_not_contains?: Maybe<String>;
  userType_starts_with?: Maybe<String>;
  userType_not_starts_with?: Maybe<String>;
  userType_ends_with?: Maybe<String>;
  userType_not_ends_with?: Maybe<String>;
  dancers_every?: Maybe<DancerWhereInput>;
  dancers_some?: Maybe<DancerWhereInput>;
  dancers_none?: Maybe<DancerWhereInput>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetToken_not?: Maybe<String>;
  resetToken_in?: Maybe<String[] | String>;
  resetToken_not_in?: Maybe<String[] | String>;
  resetToken_lt?: Maybe<String>;
  resetToken_lte?: Maybe<String>;
  resetToken_gt?: Maybe<String>;
  resetToken_gte?: Maybe<String>;
  resetToken_contains?: Maybe<String>;
  resetToken_not_contains?: Maybe<String>;
  resetToken_starts_with?: Maybe<String>;
  resetToken_not_starts_with?: Maybe<String>;
  resetToken_ends_with?: Maybe<String>;
  resetToken_not_ends_with?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  resetTokenExpiry_not?: Maybe<Float>;
  resetTokenExpiry_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_not_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_lt?: Maybe<Float>;
  resetTokenExpiry_lte?: Maybe<Float>;
  resetTokenExpiry_gt?: Maybe<Float>;
  resetTokenExpiry_gte?: Maybe<Float>;
  customRoutines_every?: Maybe<CustomRoutineWhereInput>;
  customRoutines_some?: Maybe<CustomRoutineWhereInput>;
  customRoutines_none?: Maybe<CustomRoutineWhereInput>;
  studios_every?: Maybe<StudioWhereInput>;
  studios_some?: Maybe<StudioWhereInput>;
  studios_none?: Maybe<StudioWhereInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  agreeToTerms_not?: Maybe<DateTimeInput>;
  agreeToTerms_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  agreeToTerms_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  agreeToTerms_lt?: Maybe<DateTimeInput>;
  agreeToTerms_lte?: Maybe<DateTimeInput>;
  agreeToTerms_gt?: Maybe<DateTimeInput>;
  agreeToTerms_gte?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
  readPrivacy_not?: Maybe<DateTimeInput>;
  readPrivacy_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  readPrivacy_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  readPrivacy_lt?: Maybe<DateTimeInput>;
  readPrivacy_lte?: Maybe<DateTimeInput>;
  readPrivacy_gt?: Maybe<DateTimeInput>;
  readPrivacy_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ParentWhereInput[] | ParentWhereInput>;
  OR?: Maybe<ParentWhereInput[] | ParentWhereInput>;
  NOT?: Maybe<ParentWhereInput[] | ParentWhereInput>;
}

export interface CustomRoutineWhereInput {
  custom?: Maybe<Boolean>;
  custom_not?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  studio?: Maybe<StudioWhereInput>;
  parent?: Maybe<ParentWhereInput>;
  music?: Maybe<String>;
  music_not?: Maybe<String>;
  music_in?: Maybe<String[] | String>;
  music_not_in?: Maybe<String[] | String>;
  music_lt?: Maybe<String>;
  music_lte?: Maybe<String>;
  music_gt?: Maybe<String>;
  music_gte?: Maybe<String>;
  music_contains?: Maybe<String>;
  music_not_contains?: Maybe<String>;
  music_starts_with?: Maybe<String>;
  music_not_starts_with?: Maybe<String>;
  music_ends_with?: Maybe<String>;
  music_not_ends_with?: Maybe<String>;
  musicId?: Maybe<String>;
  musicId_not?: Maybe<String>;
  musicId_in?: Maybe<String[] | String>;
  musicId_not_in?: Maybe<String[] | String>;
  musicId_lt?: Maybe<String>;
  musicId_lte?: Maybe<String>;
  musicId_gt?: Maybe<String>;
  musicId_gte?: Maybe<String>;
  musicId_contains?: Maybe<String>;
  musicId_not_contains?: Maybe<String>;
  musicId_starts_with?: Maybe<String>;
  musicId_not_starts_with?: Maybe<String>;
  musicId_ends_with?: Maybe<String>;
  musicId_not_ends_with?: Maybe<String>;
  style?: Maybe<String>;
  style_not?: Maybe<String>;
  style_in?: Maybe<String[] | String>;
  style_not_in?: Maybe<String[] | String>;
  style_lt?: Maybe<String>;
  style_lte?: Maybe<String>;
  style_gt?: Maybe<String>;
  style_gte?: Maybe<String>;
  style_contains?: Maybe<String>;
  style_not_contains?: Maybe<String>;
  style_starts_with?: Maybe<String>;
  style_not_starts_with?: Maybe<String>;
  style_ends_with?: Maybe<String>;
  style_not_ends_with?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  competitiveLevel_not?: Maybe<String>;
  competitiveLevel_in?: Maybe<String[] | String>;
  competitiveLevel_not_in?: Maybe<String[] | String>;
  competitiveLevel_lt?: Maybe<String>;
  competitiveLevel_lte?: Maybe<String>;
  competitiveLevel_gt?: Maybe<String>;
  competitiveLevel_gte?: Maybe<String>;
  competitiveLevel_contains?: Maybe<String>;
  competitiveLevel_not_contains?: Maybe<String>;
  competitiveLevel_starts_with?: Maybe<String>;
  competitiveLevel_not_starts_with?: Maybe<String>;
  competitiveLevel_ends_with?: Maybe<String>;
  competitiveLevel_not_ends_with?: Maybe<String>;
  ageDivision?: Maybe<String>;
  ageDivision_not?: Maybe<String>;
  ageDivision_in?: Maybe<String[] | String>;
  ageDivision_not_in?: Maybe<String[] | String>;
  ageDivision_lt?: Maybe<String>;
  ageDivision_lte?: Maybe<String>;
  ageDivision_gt?: Maybe<String>;
  ageDivision_gte?: Maybe<String>;
  ageDivision_contains?: Maybe<String>;
  ageDivision_not_contains?: Maybe<String>;
  ageDivision_starts_with?: Maybe<String>;
  ageDivision_not_starts_with?: Maybe<String>;
  ageDivision_ends_with?: Maybe<String>;
  ageDivision_not_ends_with?: Maybe<String>;
  performanceName?: Maybe<String>;
  performanceName_not?: Maybe<String>;
  performanceName_in?: Maybe<String[] | String>;
  performanceName_not_in?: Maybe<String[] | String>;
  performanceName_lt?: Maybe<String>;
  performanceName_lte?: Maybe<String>;
  performanceName_gt?: Maybe<String>;
  performanceName_gte?: Maybe<String>;
  performanceName_contains?: Maybe<String>;
  performanceName_not_contains?: Maybe<String>;
  performanceName_starts_with?: Maybe<String>;
  performanceName_not_starts_with?: Maybe<String>;
  performanceName_ends_with?: Maybe<String>;
  performanceName_not_ends_with?: Maybe<String>;
  day?: Maybe<String>;
  day_not?: Maybe<String>;
  day_in?: Maybe<String[] | String>;
  day_not_in?: Maybe<String[] | String>;
  day_lt?: Maybe<String>;
  day_lte?: Maybe<String>;
  day_gt?: Maybe<String>;
  day_gte?: Maybe<String>;
  day_contains?: Maybe<String>;
  day_not_contains?: Maybe<String>;
  day_starts_with?: Maybe<String>;
  day_not_starts_with?: Maybe<String>;
  day_ends_with?: Maybe<String>;
  day_not_ends_with?: Maybe<String>;
  startTime?: Maybe<String>;
  startTime_not?: Maybe<String>;
  startTime_in?: Maybe<String[] | String>;
  startTime_not_in?: Maybe<String[] | String>;
  startTime_lt?: Maybe<String>;
  startTime_lte?: Maybe<String>;
  startTime_gt?: Maybe<String>;
  startTime_gte?: Maybe<String>;
  startTime_contains?: Maybe<String>;
  startTime_not_contains?: Maybe<String>;
  startTime_starts_with?: Maybe<String>;
  startTime_not_starts_with?: Maybe<String>;
  startTime_ends_with?: Maybe<String>;
  startTime_not_ends_with?: Maybe<String>;
  endTime?: Maybe<String>;
  endTime_not?: Maybe<String>;
  endTime_in?: Maybe<String[] | String>;
  endTime_not_in?: Maybe<String[] | String>;
  endTime_lt?: Maybe<String>;
  endTime_lte?: Maybe<String>;
  endTime_gt?: Maybe<String>;
  endTime_gte?: Maybe<String>;
  endTime_contains?: Maybe<String>;
  endTime_not_contains?: Maybe<String>;
  endTime_starts_with?: Maybe<String>;
  endTime_not_starts_with?: Maybe<String>;
  endTime_ends_with?: Maybe<String>;
  endTime_not_ends_with?: Maybe<String>;
  shoes?: Maybe<String>;
  shoes_not?: Maybe<String>;
  shoes_in?: Maybe<String[] | String>;
  shoes_not_in?: Maybe<String[] | String>;
  shoes_lt?: Maybe<String>;
  shoes_lte?: Maybe<String>;
  shoes_gt?: Maybe<String>;
  shoes_gte?: Maybe<String>;
  shoes_contains?: Maybe<String>;
  shoes_not_contains?: Maybe<String>;
  shoes_starts_with?: Maybe<String>;
  shoes_not_starts_with?: Maybe<String>;
  shoes_ends_with?: Maybe<String>;
  shoes_not_ends_with?: Maybe<String>;
  tights?: Maybe<String>;
  tights_not?: Maybe<String>;
  tights_in?: Maybe<String[] | String>;
  tights_not_in?: Maybe<String[] | String>;
  tights_lt?: Maybe<String>;
  tights_lte?: Maybe<String>;
  tights_gt?: Maybe<String>;
  tights_gte?: Maybe<String>;
  tights_contains?: Maybe<String>;
  tights_not_contains?: Maybe<String>;
  tights_starts_with?: Maybe<String>;
  tights_not_starts_with?: Maybe<String>;
  tights_ends_with?: Maybe<String>;
  tights_not_ends_with?: Maybe<String>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  dancers_every?: Maybe<DancerWhereInput>;
  dancers_some?: Maybe<DancerWhereInput>;
  dancers_none?: Maybe<DancerWhereInput>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  entryNumber?: Maybe<String>;
  entryNumber_not?: Maybe<String>;
  entryNumber_in?: Maybe<String[] | String>;
  entryNumber_not_in?: Maybe<String[] | String>;
  entryNumber_lt?: Maybe<String>;
  entryNumber_lte?: Maybe<String>;
  entryNumber_gt?: Maybe<String>;
  entryNumber_gte?: Maybe<String>;
  entryNumber_contains?: Maybe<String>;
  entryNumber_not_contains?: Maybe<String>;
  entryNumber_starts_with?: Maybe<String>;
  entryNumber_not_starts_with?: Maybe<String>;
  entryNumber_ends_with?: Maybe<String>;
  entryNumber_not_ends_with?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryTime_not?: Maybe<String>;
  entryTime_in?: Maybe<String[] | String>;
  entryTime_not_in?: Maybe<String[] | String>;
  entryTime_lt?: Maybe<String>;
  entryTime_lte?: Maybe<String>;
  entryTime_gt?: Maybe<String>;
  entryTime_gte?: Maybe<String>;
  entryTime_contains?: Maybe<String>;
  entryTime_not_contains?: Maybe<String>;
  entryTime_starts_with?: Maybe<String>;
  entryTime_not_starts_with?: Maybe<String>;
  entryTime_ends_with?: Maybe<String>;
  entryTime_not_ends_with?: Maybe<String>;
  entryDay?: Maybe<String>;
  entryDay_not?: Maybe<String>;
  entryDay_in?: Maybe<String[] | String>;
  entryDay_not_in?: Maybe<String[] | String>;
  entryDay_lt?: Maybe<String>;
  entryDay_lte?: Maybe<String>;
  entryDay_gt?: Maybe<String>;
  entryDay_gte?: Maybe<String>;
  entryDay_contains?: Maybe<String>;
  entryDay_not_contains?: Maybe<String>;
  entryDay_starts_with?: Maybe<String>;
  entryDay_not_starts_with?: Maybe<String>;
  entryDay_ends_with?: Maybe<String>;
  entryDay_not_ends_with?: Maybe<String>;
  AND?: Maybe<CustomRoutineWhereInput[] | CustomRoutineWhereInput>;
  OR?: Maybe<CustomRoutineWhereInput[] | CustomRoutineWhereInput>;
  NOT?: Maybe<CustomRoutineWhereInput[] | CustomRoutineWhereInput>;
}

export interface EnrollmentRequestWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  studio?: Maybe<StudioWhereInput>;
  parent?: Maybe<ParentWhereInput>;
  dancer?: Maybe<DancerWhereInput>;
  classesRequested_every?: Maybe<DanceClassWhereInput>;
  classesRequested_some?: Maybe<DanceClassWhereInput>;
  classesRequested_none?: Maybe<DanceClassWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EnrollmentRequestWhereInput[] | EnrollmentRequestWhereInput>;
  OR?: Maybe<EnrollmentRequestWhereInput[] | EnrollmentRequestWhereInput>;
  NOT?: Maybe<EnrollmentRequestWhereInput[] | EnrollmentRequestWhereInput>;
}

export interface StudioEventWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  studio?: Maybe<StudioWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  beginDate?: Maybe<DateTimeInput>;
  beginDate_not?: Maybe<DateTimeInput>;
  beginDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  beginDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  beginDate_lt?: Maybe<DateTimeInput>;
  beginDate_lte?: Maybe<DateTimeInput>;
  beginDate_gt?: Maybe<DateTimeInput>;
  beginDate_gte?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  address1?: Maybe<String>;
  address1_not?: Maybe<String>;
  address1_in?: Maybe<String[] | String>;
  address1_not_in?: Maybe<String[] | String>;
  address1_lt?: Maybe<String>;
  address1_lte?: Maybe<String>;
  address1_gt?: Maybe<String>;
  address1_gte?: Maybe<String>;
  address1_contains?: Maybe<String>;
  address1_not_contains?: Maybe<String>;
  address1_starts_with?: Maybe<String>;
  address1_not_starts_with?: Maybe<String>;
  address1_ends_with?: Maybe<String>;
  address1_not_ends_with?: Maybe<String>;
  address2?: Maybe<String>;
  address2_not?: Maybe<String>;
  address2_in?: Maybe<String[] | String>;
  address2_not_in?: Maybe<String[] | String>;
  address2_lt?: Maybe<String>;
  address2_lte?: Maybe<String>;
  address2_gt?: Maybe<String>;
  address2_gte?: Maybe<String>;
  address2_contains?: Maybe<String>;
  address2_not_contains?: Maybe<String>;
  address2_starts_with?: Maybe<String>;
  address2_not_starts_with?: Maybe<String>;
  address2_ends_with?: Maybe<String>;
  address2_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zip?: Maybe<String>;
  zip_not?: Maybe<String>;
  zip_in?: Maybe<String[] | String>;
  zip_not_in?: Maybe<String[] | String>;
  zip_lt?: Maybe<String>;
  zip_lte?: Maybe<String>;
  zip_gt?: Maybe<String>;
  zip_gte?: Maybe<String>;
  zip_contains?: Maybe<String>;
  zip_not_contains?: Maybe<String>;
  zip_starts_with?: Maybe<String>;
  zip_not_starts_with?: Maybe<String>;
  zip_ends_with?: Maybe<String>;
  zip_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  AND?: Maybe<StudioEventWhereInput[] | StudioEventWhereInput>;
  OR?: Maybe<StudioEventWhereInput[] | StudioEventWhereInput>;
  NOT?: Maybe<StudioEventWhereInput[] | StudioEventWhereInput>;
}

export interface AccessRequestWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  studio?: Maybe<StudioWhereInput>;
  parent?: Maybe<ParentWhereInput>;
  AND?: Maybe<AccessRequestWhereInput[] | AccessRequestWhereInput>;
  OR?: Maybe<AccessRequestWhereInput[] | AccessRequestWhereInput>;
  NOT?: Maybe<AccessRequestWhereInput[] | AccessRequestWhereInput>;
}

export type CustomRoutineWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type DanceClassWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type DancerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type EnrollmentRequestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type HairStyleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MakeupSetWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ParentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export type ParentEventWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ParentEventWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  parent?: Maybe<ParentWhereInput>;
  studio?: Maybe<StudioWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  beginDate?: Maybe<DateTimeInput>;
  beginDate_not?: Maybe<DateTimeInput>;
  beginDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  beginDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  beginDate_lt?: Maybe<DateTimeInput>;
  beginDate_lte?: Maybe<DateTimeInput>;
  beginDate_gt?: Maybe<DateTimeInput>;
  beginDate_gte?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  address1?: Maybe<String>;
  address1_not?: Maybe<String>;
  address1_in?: Maybe<String[] | String>;
  address1_not_in?: Maybe<String[] | String>;
  address1_lt?: Maybe<String>;
  address1_lte?: Maybe<String>;
  address1_gt?: Maybe<String>;
  address1_gte?: Maybe<String>;
  address1_contains?: Maybe<String>;
  address1_not_contains?: Maybe<String>;
  address1_starts_with?: Maybe<String>;
  address1_not_starts_with?: Maybe<String>;
  address1_ends_with?: Maybe<String>;
  address1_not_ends_with?: Maybe<String>;
  address2?: Maybe<String>;
  address2_not?: Maybe<String>;
  address2_in?: Maybe<String[] | String>;
  address2_not_in?: Maybe<String[] | String>;
  address2_lt?: Maybe<String>;
  address2_lte?: Maybe<String>;
  address2_gt?: Maybe<String>;
  address2_gte?: Maybe<String>;
  address2_contains?: Maybe<String>;
  address2_not_contains?: Maybe<String>;
  address2_starts_with?: Maybe<String>;
  address2_not_starts_with?: Maybe<String>;
  address2_ends_with?: Maybe<String>;
  address2_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zip?: Maybe<String>;
  zip_not?: Maybe<String>;
  zip_in?: Maybe<String[] | String>;
  zip_not_in?: Maybe<String[] | String>;
  zip_lt?: Maybe<String>;
  zip_lte?: Maybe<String>;
  zip_gt?: Maybe<String>;
  zip_gte?: Maybe<String>;
  zip_contains?: Maybe<String>;
  zip_not_contains?: Maybe<String>;
  zip_starts_with?: Maybe<String>;
  zip_not_starts_with?: Maybe<String>;
  zip_ends_with?: Maybe<String>;
  zip_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  AND?: Maybe<ParentEventWhereInput[] | ParentEventWhereInput>;
  OR?: Maybe<ParentEventWhereInput[] | ParentEventWhereInput>;
  NOT?: Maybe<ParentEventWhereInput[] | ParentEventWhereInput>;
}

export type ParentNoteWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ParentNoteWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  parent?: Maybe<ParentWhereInput>;
  dance?: Maybe<DanceClassWhereInput>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  AND?: Maybe<ParentNoteWhereInput[] | ParentNoteWhereInput>;
  OR?: Maybe<ParentNoteWhereInput[] | ParentNoteWhereInput>;
  NOT?: Maybe<ParentNoteWhereInput[] | ParentNoteWhereInput>;
}

export type StudioWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export type StudioEventWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AccessRequestCreateInput {
  id?: Maybe<ID_Input>;
  studio: StudioCreateOneWithoutAccessRequestsInput;
  parent: ParentCreateOneInput;
}

export interface StudioCreateOneWithoutAccessRequestsInput {
  create?: Maybe<StudioCreateWithoutAccessRequestsInput>;
  connect?: Maybe<StudioWhereUniqueInput>;
}

export interface StudioCreateWithoutAccessRequestsInput {
  id?: Maybe<ID_Input>;
  email: String;
  studioName: String;
  userType: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  danceClasses?: Maybe<DanceClassCreateManyWithoutStudioInput>;
  styles?: Maybe<StudioCreatestylesInput>;
  competitiveLevels?: Maybe<StudioCreatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioCreateageDivisionsInput>;
  makeupSets?: Maybe<MakeupSetCreateManyWithoutStudioInput>;
  hairStyles?: Maybe<HairStyleCreateManyWithoutStudioInput>;
  dancers?: Maybe<DancerCreateManyWithoutStudiosInput>;
  events?: Maybe<StudioEventCreateManyWithoutStudioInput>;
  website?: Maybe<String>;
  enrollmentRequests?: Maybe<EnrollmentRequestCreateManyWithoutStudioInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface DanceClassCreateManyWithoutStudioInput {
  create?: Maybe<
    DanceClassCreateWithoutStudioInput[] | DanceClassCreateWithoutStudioInput
  >;
  connect?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
}

export interface DanceClassCreateWithoutStudioInput {
  id?: Maybe<ID_Input>;
  name: String;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  style?: Maybe<String>;
  tights?: Maybe<String>;
  shoes?: Maybe<String>;
  notes?: Maybe<String>;
  dancers?: Maybe<DancerCreateManyWithoutDanceClassesInput>;
  makeupSet?: Maybe<MakeupSetCreateOneWithoutDanceClassesInput>;
  size: String;
  custom: Boolean;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
  videoUrl?: Maybe<String>;
  videoId?: Maybe<String>;
}

export interface DancerCreateManyWithoutDanceClassesInput {
  create?: Maybe<
    | DancerCreateWithoutDanceClassesInput[]
    | DancerCreateWithoutDanceClassesInput
  >;
  connect?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
}

export interface DancerCreateWithoutDanceClassesInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  parent: ParentCreateOneWithoutDancersInput;
  requests?: Maybe<EnrollmentRequestCreateOneWithoutDancerInput>;
  customRoutines?: Maybe<CustomRoutineCreateManyWithoutDancersInput>;
  avatar?: Maybe<String>;
  avatarId?: Maybe<String>;
  lastName?: Maybe<String>;
  studios?: Maybe<StudioCreateManyWithoutDancersInput>;
}

export interface ParentCreateOneWithoutDancersInput {
  create?: Maybe<ParentCreateWithoutDancersInput>;
  connect?: Maybe<ParentWhereUniqueInput>;
}

export interface ParentCreateWithoutDancersInput {
  id?: Maybe<ID_Input>;
  email: String;
  firstName: String;
  lastName?: Maybe<String>;
  userType: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  customRoutines?: Maybe<CustomRoutineCreateManyWithoutParentInput>;
  studios?: Maybe<StudioCreateManyInput>;
  accessRequests?: Maybe<ParentCreateaccessRequestsInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface CustomRoutineCreateManyWithoutParentInput {
  create?: Maybe<
    | CustomRoutineCreateWithoutParentInput[]
    | CustomRoutineCreateWithoutParentInput
  >;
  connect?: Maybe<
    CustomRoutineWhereUniqueInput[] | CustomRoutineWhereUniqueInput
  >;
}

export interface CustomRoutineCreateWithoutParentInput {
  custom: Boolean;
  id?: Maybe<ID_Input>;
  name: String;
  studio?: Maybe<StudioCreateOneInput>;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  style?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  shoes?: Maybe<String>;
  tights?: Maybe<String>;
  notes?: Maybe<String>;
  dancers?: Maybe<DancerCreateManyWithoutCustomRoutinesInput>;
  type?: Maybe<String>;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
}

export interface StudioCreateOneInput {
  create?: Maybe<StudioCreateInput>;
  connect?: Maybe<StudioWhereUniqueInput>;
}

export interface StudioCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  studioName: String;
  userType: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  danceClasses?: Maybe<DanceClassCreateManyWithoutStudioInput>;
  styles?: Maybe<StudioCreatestylesInput>;
  competitiveLevels?: Maybe<StudioCreatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioCreateageDivisionsInput>;
  makeupSets?: Maybe<MakeupSetCreateManyWithoutStudioInput>;
  hairStyles?: Maybe<HairStyleCreateManyWithoutStudioInput>;
  dancers?: Maybe<DancerCreateManyWithoutStudiosInput>;
  events?: Maybe<StudioEventCreateManyWithoutStudioInput>;
  website?: Maybe<String>;
  enrollmentRequests?: Maybe<EnrollmentRequestCreateManyWithoutStudioInput>;
  accessRequests?: Maybe<AccessRequestCreateManyWithoutStudioInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface StudioCreatestylesInput {
  set?: Maybe<String[] | String>;
}

export interface StudioCreatecompetitiveLevelsInput {
  set?: Maybe<String[] | String>;
}

export interface StudioCreateageDivisionsInput {
  set?: Maybe<String[] | String>;
}

export interface MakeupSetCreateManyWithoutStudioInput {
  create?: Maybe<
    MakeupSetCreateWithoutStudioInput[] | MakeupSetCreateWithoutStudioInput
  >;
  connect?: Maybe<MakeupSetWhereUniqueInput[] | MakeupSetWhereUniqueInput>;
}

export interface MakeupSetCreateWithoutStudioInput {
  id?: Maybe<ID_Input>;
  name: String;
  lipstick?: Maybe<String>;
  eyeShadow?: Maybe<String>;
  eyeLids?: Maybe<String>;
  eyeCrease?: Maybe<String>;
  eyeLiner?: Maybe<String>;
  eyelashes?: Maybe<String>;
  foundation?: Maybe<String>;
  powder?: Maybe<String>;
  blush?: Maybe<String>;
  bronzer?: Maybe<String>;
  applyToCategories?: Maybe<String>;
  notes?: Maybe<String>;
  danceClasses?: Maybe<DanceClassCreateManyWithoutMakeupSetInput>;
}

export interface DanceClassCreateManyWithoutMakeupSetInput {
  create?: Maybe<
    | DanceClassCreateWithoutMakeupSetInput[]
    | DanceClassCreateWithoutMakeupSetInput
  >;
  connect?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
}

export interface DanceClassCreateWithoutMakeupSetInput {
  id?: Maybe<ID_Input>;
  name: String;
  studio: StudioCreateOneWithoutDanceClassesInput;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  style?: Maybe<String>;
  tights?: Maybe<String>;
  shoes?: Maybe<String>;
  notes?: Maybe<String>;
  dancers?: Maybe<DancerCreateManyWithoutDanceClassesInput>;
  size: String;
  custom: Boolean;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
  videoUrl?: Maybe<String>;
  videoId?: Maybe<String>;
}

export interface StudioCreateOneWithoutDanceClassesInput {
  create?: Maybe<StudioCreateWithoutDanceClassesInput>;
  connect?: Maybe<StudioWhereUniqueInput>;
}

export interface StudioCreateWithoutDanceClassesInput {
  id?: Maybe<ID_Input>;
  email: String;
  studioName: String;
  userType: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  styles?: Maybe<StudioCreatestylesInput>;
  competitiveLevels?: Maybe<StudioCreatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioCreateageDivisionsInput>;
  makeupSets?: Maybe<MakeupSetCreateManyWithoutStudioInput>;
  hairStyles?: Maybe<HairStyleCreateManyWithoutStudioInput>;
  dancers?: Maybe<DancerCreateManyWithoutStudiosInput>;
  events?: Maybe<StudioEventCreateManyWithoutStudioInput>;
  website?: Maybe<String>;
  enrollmentRequests?: Maybe<EnrollmentRequestCreateManyWithoutStudioInput>;
  accessRequests?: Maybe<AccessRequestCreateManyWithoutStudioInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface HairStyleCreateManyWithoutStudioInput {
  create?: Maybe<
    HairStyleCreateWithoutStudioInput[] | HairStyleCreateWithoutStudioInput
  >;
  connect?: Maybe<HairStyleWhereUniqueInput[] | HairStyleWhereUniqueInput>;
}

export interface HairStyleCreateWithoutStudioInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
}

export interface DancerCreateManyWithoutStudiosInput {
  create?: Maybe<
    DancerCreateWithoutStudiosInput[] | DancerCreateWithoutStudiosInput
  >;
  connect?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
}

export interface DancerCreateWithoutStudiosInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  parent: ParentCreateOneWithoutDancersInput;
  requests?: Maybe<EnrollmentRequestCreateOneWithoutDancerInput>;
  danceClasses?: Maybe<DanceClassCreateManyWithoutDancersInput>;
  customRoutines?: Maybe<CustomRoutineCreateManyWithoutDancersInput>;
  avatar?: Maybe<String>;
  avatarId?: Maybe<String>;
  lastName?: Maybe<String>;
}

export interface EnrollmentRequestCreateOneWithoutDancerInput {
  create?: Maybe<EnrollmentRequestCreateWithoutDancerInput>;
  connect?: Maybe<EnrollmentRequestWhereUniqueInput>;
}

export interface EnrollmentRequestCreateWithoutDancerInput {
  id?: Maybe<ID_Input>;
  studio: StudioCreateOneWithoutEnrollmentRequestsInput;
  parent: ParentCreateOneInput;
  classesRequested?: Maybe<DanceClassCreateManyInput>;
}

export interface StudioCreateOneWithoutEnrollmentRequestsInput {
  create?: Maybe<StudioCreateWithoutEnrollmentRequestsInput>;
  connect?: Maybe<StudioWhereUniqueInput>;
}

export interface StudioCreateWithoutEnrollmentRequestsInput {
  id?: Maybe<ID_Input>;
  email: String;
  studioName: String;
  userType: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  danceClasses?: Maybe<DanceClassCreateManyWithoutStudioInput>;
  styles?: Maybe<StudioCreatestylesInput>;
  competitiveLevels?: Maybe<StudioCreatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioCreateageDivisionsInput>;
  makeupSets?: Maybe<MakeupSetCreateManyWithoutStudioInput>;
  hairStyles?: Maybe<HairStyleCreateManyWithoutStudioInput>;
  dancers?: Maybe<DancerCreateManyWithoutStudiosInput>;
  events?: Maybe<StudioEventCreateManyWithoutStudioInput>;
  website?: Maybe<String>;
  accessRequests?: Maybe<AccessRequestCreateManyWithoutStudioInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface StudioEventCreateManyWithoutStudioInput {
  create?: Maybe<
    StudioEventCreateWithoutStudioInput[] | StudioEventCreateWithoutStudioInput
  >;
  connect?: Maybe<StudioEventWhereUniqueInput[] | StudioEventWhereUniqueInput>;
}

export interface StudioEventCreateWithoutStudioInput {
  id?: Maybe<ID_Input>;
  name: String;
  type: String;
  appliesTo?: Maybe<StudioEventCreateappliesToInput>;
  beginDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  location?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<String>;
  url?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface StudioEventCreateappliesToInput {
  set?: Maybe<String[] | String>;
}

export interface AccessRequestCreateManyWithoutStudioInput {
  create?: Maybe<
    | AccessRequestCreateWithoutStudioInput[]
    | AccessRequestCreateWithoutStudioInput
  >;
  connect?: Maybe<
    AccessRequestWhereUniqueInput[] | AccessRequestWhereUniqueInput
  >;
}

export interface AccessRequestCreateWithoutStudioInput {
  id?: Maybe<ID_Input>;
  parent: ParentCreateOneInput;
}

export interface ParentCreateOneInput {
  create?: Maybe<ParentCreateInput>;
  connect?: Maybe<ParentWhereUniqueInput>;
}

export interface ParentCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  firstName: String;
  lastName?: Maybe<String>;
  userType: String;
  dancers?: Maybe<DancerCreateManyWithoutParentInput>;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  customRoutines?: Maybe<CustomRoutineCreateManyWithoutParentInput>;
  studios?: Maybe<StudioCreateManyInput>;
  accessRequests?: Maybe<ParentCreateaccessRequestsInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface DancerCreateManyWithoutParentInput {
  create?: Maybe<
    DancerCreateWithoutParentInput[] | DancerCreateWithoutParentInput
  >;
  connect?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
}

export interface DancerCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  requests?: Maybe<EnrollmentRequestCreateOneWithoutDancerInput>;
  danceClasses?: Maybe<DanceClassCreateManyWithoutDancersInput>;
  customRoutines?: Maybe<CustomRoutineCreateManyWithoutDancersInput>;
  avatar?: Maybe<String>;
  avatarId?: Maybe<String>;
  lastName?: Maybe<String>;
  studios?: Maybe<StudioCreateManyWithoutDancersInput>;
}

export interface DanceClassCreateManyWithoutDancersInput {
  create?: Maybe<
    DanceClassCreateWithoutDancersInput[] | DanceClassCreateWithoutDancersInput
  >;
  connect?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
}

export interface DanceClassCreateWithoutDancersInput {
  id?: Maybe<ID_Input>;
  name: String;
  studio: StudioCreateOneWithoutDanceClassesInput;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  style?: Maybe<String>;
  tights?: Maybe<String>;
  shoes?: Maybe<String>;
  notes?: Maybe<String>;
  makeupSet?: Maybe<MakeupSetCreateOneWithoutDanceClassesInput>;
  size: String;
  custom: Boolean;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
  videoUrl?: Maybe<String>;
  videoId?: Maybe<String>;
}

export interface MakeupSetCreateOneWithoutDanceClassesInput {
  create?: Maybe<MakeupSetCreateWithoutDanceClassesInput>;
  connect?: Maybe<MakeupSetWhereUniqueInput>;
}

export interface MakeupSetCreateWithoutDanceClassesInput {
  id?: Maybe<ID_Input>;
  name: String;
  studio: StudioCreateOneWithoutMakeupSetsInput;
  lipstick?: Maybe<String>;
  eyeShadow?: Maybe<String>;
  eyeLids?: Maybe<String>;
  eyeCrease?: Maybe<String>;
  eyeLiner?: Maybe<String>;
  eyelashes?: Maybe<String>;
  foundation?: Maybe<String>;
  powder?: Maybe<String>;
  blush?: Maybe<String>;
  bronzer?: Maybe<String>;
  applyToCategories?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface StudioCreateOneWithoutMakeupSetsInput {
  create?: Maybe<StudioCreateWithoutMakeupSetsInput>;
  connect?: Maybe<StudioWhereUniqueInput>;
}

export interface StudioCreateWithoutMakeupSetsInput {
  id?: Maybe<ID_Input>;
  email: String;
  studioName: String;
  userType: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  danceClasses?: Maybe<DanceClassCreateManyWithoutStudioInput>;
  styles?: Maybe<StudioCreatestylesInput>;
  competitiveLevels?: Maybe<StudioCreatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioCreateageDivisionsInput>;
  hairStyles?: Maybe<HairStyleCreateManyWithoutStudioInput>;
  dancers?: Maybe<DancerCreateManyWithoutStudiosInput>;
  events?: Maybe<StudioEventCreateManyWithoutStudioInput>;
  website?: Maybe<String>;
  enrollmentRequests?: Maybe<EnrollmentRequestCreateManyWithoutStudioInput>;
  accessRequests?: Maybe<AccessRequestCreateManyWithoutStudioInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface EnrollmentRequestCreateManyWithoutStudioInput {
  create?: Maybe<
    | EnrollmentRequestCreateWithoutStudioInput[]
    | EnrollmentRequestCreateWithoutStudioInput
  >;
  connect?: Maybe<
    EnrollmentRequestWhereUniqueInput[] | EnrollmentRequestWhereUniqueInput
  >;
}

export interface EnrollmentRequestCreateWithoutStudioInput {
  id?: Maybe<ID_Input>;
  parent: ParentCreateOneInput;
  dancer: DancerCreateOneWithoutRequestsInput;
  classesRequested?: Maybe<DanceClassCreateManyInput>;
}

export interface DancerCreateOneWithoutRequestsInput {
  create?: Maybe<DancerCreateWithoutRequestsInput>;
  connect?: Maybe<DancerWhereUniqueInput>;
}

export interface DancerCreateWithoutRequestsInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  parent: ParentCreateOneWithoutDancersInput;
  danceClasses?: Maybe<DanceClassCreateManyWithoutDancersInput>;
  customRoutines?: Maybe<CustomRoutineCreateManyWithoutDancersInput>;
  avatar?: Maybe<String>;
  avatarId?: Maybe<String>;
  lastName?: Maybe<String>;
  studios?: Maybe<StudioCreateManyWithoutDancersInput>;
}

export interface CustomRoutineCreateManyWithoutDancersInput {
  create?: Maybe<
    | CustomRoutineCreateWithoutDancersInput[]
    | CustomRoutineCreateWithoutDancersInput
  >;
  connect?: Maybe<
    CustomRoutineWhereUniqueInput[] | CustomRoutineWhereUniqueInput
  >;
}

export interface CustomRoutineCreateWithoutDancersInput {
  custom: Boolean;
  id?: Maybe<ID_Input>;
  name: String;
  studio?: Maybe<StudioCreateOneInput>;
  parent: ParentCreateOneWithoutCustomRoutinesInput;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  style?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  shoes?: Maybe<String>;
  tights?: Maybe<String>;
  notes?: Maybe<String>;
  type?: Maybe<String>;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
}

export interface ParentCreateOneWithoutCustomRoutinesInput {
  create?: Maybe<ParentCreateWithoutCustomRoutinesInput>;
  connect?: Maybe<ParentWhereUniqueInput>;
}

export interface ParentCreateWithoutCustomRoutinesInput {
  id?: Maybe<ID_Input>;
  email: String;
  firstName: String;
  lastName?: Maybe<String>;
  userType: String;
  dancers?: Maybe<DancerCreateManyWithoutParentInput>;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  studios?: Maybe<StudioCreateManyInput>;
  accessRequests?: Maybe<ParentCreateaccessRequestsInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface StudioCreateManyInput {
  create?: Maybe<StudioCreateInput[] | StudioCreateInput>;
  connect?: Maybe<StudioWhereUniqueInput[] | StudioWhereUniqueInput>;
}

export interface ParentCreateaccessRequestsInput {
  set?: Maybe<ID_Input[] | ID_Input>;
}

export interface StudioCreateManyWithoutDancersInput {
  create?: Maybe<
    StudioCreateWithoutDancersInput[] | StudioCreateWithoutDancersInput
  >;
  connect?: Maybe<StudioWhereUniqueInput[] | StudioWhereUniqueInput>;
}

export interface StudioCreateWithoutDancersInput {
  id?: Maybe<ID_Input>;
  email: String;
  studioName: String;
  userType: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  danceClasses?: Maybe<DanceClassCreateManyWithoutStudioInput>;
  styles?: Maybe<StudioCreatestylesInput>;
  competitiveLevels?: Maybe<StudioCreatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioCreateageDivisionsInput>;
  makeupSets?: Maybe<MakeupSetCreateManyWithoutStudioInput>;
  hairStyles?: Maybe<HairStyleCreateManyWithoutStudioInput>;
  events?: Maybe<StudioEventCreateManyWithoutStudioInput>;
  website?: Maybe<String>;
  enrollmentRequests?: Maybe<EnrollmentRequestCreateManyWithoutStudioInput>;
  accessRequests?: Maybe<AccessRequestCreateManyWithoutStudioInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface DanceClassCreateManyInput {
  create?: Maybe<DanceClassCreateInput[] | DanceClassCreateInput>;
  connect?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
}

export interface DanceClassCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  studio: StudioCreateOneWithoutDanceClassesInput;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  style?: Maybe<String>;
  tights?: Maybe<String>;
  shoes?: Maybe<String>;
  notes?: Maybe<String>;
  dancers?: Maybe<DancerCreateManyWithoutDanceClassesInput>;
  makeupSet?: Maybe<MakeupSetCreateOneWithoutDanceClassesInput>;
  size: String;
  custom: Boolean;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
  videoUrl?: Maybe<String>;
  videoId?: Maybe<String>;
}

export interface DancerCreateManyWithoutCustomRoutinesInput {
  create?: Maybe<
    | DancerCreateWithoutCustomRoutinesInput[]
    | DancerCreateWithoutCustomRoutinesInput
  >;
  connect?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
}

export interface DancerCreateWithoutCustomRoutinesInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  parent: ParentCreateOneWithoutDancersInput;
  requests?: Maybe<EnrollmentRequestCreateOneWithoutDancerInput>;
  danceClasses?: Maybe<DanceClassCreateManyWithoutDancersInput>;
  avatar?: Maybe<String>;
  avatarId?: Maybe<String>;
  lastName?: Maybe<String>;
  studios?: Maybe<StudioCreateManyWithoutDancersInput>;
}

export interface AccessRequestUpdateInput {
  studio?: Maybe<StudioUpdateOneRequiredWithoutAccessRequestsInput>;
  parent?: Maybe<ParentUpdateOneRequiredInput>;
}

export interface StudioUpdateOneRequiredWithoutAccessRequestsInput {
  create?: Maybe<StudioCreateWithoutAccessRequestsInput>;
  update?: Maybe<StudioUpdateWithoutAccessRequestsDataInput>;
  upsert?: Maybe<StudioUpsertWithoutAccessRequestsInput>;
  connect?: Maybe<StudioWhereUniqueInput>;
}

export interface StudioUpdateWithoutAccessRequestsDataInput {
  email?: Maybe<String>;
  studioName?: Maybe<String>;
  userType?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  danceClasses?: Maybe<DanceClassUpdateManyWithoutStudioInput>;
  styles?: Maybe<StudioUpdatestylesInput>;
  competitiveLevels?: Maybe<StudioUpdatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioUpdateageDivisionsInput>;
  makeupSets?: Maybe<MakeupSetUpdateManyWithoutStudioInput>;
  hairStyles?: Maybe<HairStyleUpdateManyWithoutStudioInput>;
  dancers?: Maybe<DancerUpdateManyWithoutStudiosInput>;
  events?: Maybe<StudioEventUpdateManyWithoutStudioInput>;
  website?: Maybe<String>;
  enrollmentRequests?: Maybe<EnrollmentRequestUpdateManyWithoutStudioInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface DanceClassUpdateManyWithoutStudioInput {
  create?: Maybe<
    DanceClassCreateWithoutStudioInput[] | DanceClassCreateWithoutStudioInput
  >;
  delete?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
  connect?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
  set?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
  disconnect?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
  update?: Maybe<
    | DanceClassUpdateWithWhereUniqueWithoutStudioInput[]
    | DanceClassUpdateWithWhereUniqueWithoutStudioInput
  >;
  upsert?: Maybe<
    | DanceClassUpsertWithWhereUniqueWithoutStudioInput[]
    | DanceClassUpsertWithWhereUniqueWithoutStudioInput
  >;
  deleteMany?: Maybe<DanceClassScalarWhereInput[] | DanceClassScalarWhereInput>;
  updateMany?: Maybe<
    | DanceClassUpdateManyWithWhereNestedInput[]
    | DanceClassUpdateManyWithWhereNestedInput
  >;
}

export interface DanceClassUpdateWithWhereUniqueWithoutStudioInput {
  where: DanceClassWhereUniqueInput;
  data: DanceClassUpdateWithoutStudioDataInput;
}

export interface DanceClassUpdateWithoutStudioDataInput {
  name?: Maybe<String>;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  style?: Maybe<String>;
  tights?: Maybe<String>;
  shoes?: Maybe<String>;
  notes?: Maybe<String>;
  dancers?: Maybe<DancerUpdateManyWithoutDanceClassesInput>;
  makeupSet?: Maybe<MakeupSetUpdateOneWithoutDanceClassesInput>;
  size?: Maybe<String>;
  custom?: Maybe<Boolean>;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
  videoUrl?: Maybe<String>;
  videoId?: Maybe<String>;
}

export interface DancerUpdateManyWithoutDanceClassesInput {
  create?: Maybe<
    | DancerCreateWithoutDanceClassesInput[]
    | DancerCreateWithoutDanceClassesInput
  >;
  delete?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
  connect?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
  set?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
  disconnect?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
  update?: Maybe<
    | DancerUpdateWithWhereUniqueWithoutDanceClassesInput[]
    | DancerUpdateWithWhereUniqueWithoutDanceClassesInput
  >;
  upsert?: Maybe<
    | DancerUpsertWithWhereUniqueWithoutDanceClassesInput[]
    | DancerUpsertWithWhereUniqueWithoutDanceClassesInput
  >;
  deleteMany?: Maybe<DancerScalarWhereInput[] | DancerScalarWhereInput>;
  updateMany?: Maybe<
    | DancerUpdateManyWithWhereNestedInput[]
    | DancerUpdateManyWithWhereNestedInput
  >;
}

export interface DancerUpdateWithWhereUniqueWithoutDanceClassesInput {
  where: DancerWhereUniqueInput;
  data: DancerUpdateWithoutDanceClassesDataInput;
}

export interface DancerUpdateWithoutDanceClassesDataInput {
  firstName?: Maybe<String>;
  parent?: Maybe<ParentUpdateOneRequiredWithoutDancersInput>;
  requests?: Maybe<EnrollmentRequestUpdateOneWithoutDancerInput>;
  customRoutines?: Maybe<CustomRoutineUpdateManyWithoutDancersInput>;
  avatar?: Maybe<String>;
  avatarId?: Maybe<String>;
  lastName?: Maybe<String>;
  studios?: Maybe<StudioUpdateManyWithoutDancersInput>;
}

export interface ParentUpdateOneRequiredWithoutDancersInput {
  create?: Maybe<ParentCreateWithoutDancersInput>;
  update?: Maybe<ParentUpdateWithoutDancersDataInput>;
  upsert?: Maybe<ParentUpsertWithoutDancersInput>;
  connect?: Maybe<ParentWhereUniqueInput>;
}

export interface ParentUpdateWithoutDancersDataInput {
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  userType?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  customRoutines?: Maybe<CustomRoutineUpdateManyWithoutParentInput>;
  studios?: Maybe<StudioUpdateManyInput>;
  accessRequests?: Maybe<ParentUpdateaccessRequestsInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface CustomRoutineUpdateManyWithoutParentInput {
  create?: Maybe<
    | CustomRoutineCreateWithoutParentInput[]
    | CustomRoutineCreateWithoutParentInput
  >;
  delete?: Maybe<
    CustomRoutineWhereUniqueInput[] | CustomRoutineWhereUniqueInput
  >;
  connect?: Maybe<
    CustomRoutineWhereUniqueInput[] | CustomRoutineWhereUniqueInput
  >;
  set?: Maybe<CustomRoutineWhereUniqueInput[] | CustomRoutineWhereUniqueInput>;
  disconnect?: Maybe<
    CustomRoutineWhereUniqueInput[] | CustomRoutineWhereUniqueInput
  >;
  update?: Maybe<
    | CustomRoutineUpdateWithWhereUniqueWithoutParentInput[]
    | CustomRoutineUpdateWithWhereUniqueWithoutParentInput
  >;
  upsert?: Maybe<
    | CustomRoutineUpsertWithWhereUniqueWithoutParentInput[]
    | CustomRoutineUpsertWithWhereUniqueWithoutParentInput
  >;
  deleteMany?: Maybe<
    CustomRoutineScalarWhereInput[] | CustomRoutineScalarWhereInput
  >;
  updateMany?: Maybe<
    | CustomRoutineUpdateManyWithWhereNestedInput[]
    | CustomRoutineUpdateManyWithWhereNestedInput
  >;
}

export interface CustomRoutineUpdateWithWhereUniqueWithoutParentInput {
  where: CustomRoutineWhereUniqueInput;
  data: CustomRoutineUpdateWithoutParentDataInput;
}

export interface CustomRoutineUpdateWithoutParentDataInput {
  custom?: Maybe<Boolean>;
  name?: Maybe<String>;
  studio?: Maybe<StudioUpdateOneInput>;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  style?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  shoes?: Maybe<String>;
  tights?: Maybe<String>;
  notes?: Maybe<String>;
  dancers?: Maybe<DancerUpdateManyWithoutCustomRoutinesInput>;
  type?: Maybe<String>;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
}

export interface StudioUpdateOneInput {
  create?: Maybe<StudioCreateInput>;
  update?: Maybe<StudioUpdateDataInput>;
  upsert?: Maybe<StudioUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<StudioWhereUniqueInput>;
}

export interface StudioUpdateDataInput {
  email?: Maybe<String>;
  studioName?: Maybe<String>;
  userType?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  danceClasses?: Maybe<DanceClassUpdateManyWithoutStudioInput>;
  styles?: Maybe<StudioUpdatestylesInput>;
  competitiveLevels?: Maybe<StudioUpdatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioUpdateageDivisionsInput>;
  makeupSets?: Maybe<MakeupSetUpdateManyWithoutStudioInput>;
  hairStyles?: Maybe<HairStyleUpdateManyWithoutStudioInput>;
  dancers?: Maybe<DancerUpdateManyWithoutStudiosInput>;
  events?: Maybe<StudioEventUpdateManyWithoutStudioInput>;
  website?: Maybe<String>;
  enrollmentRequests?: Maybe<EnrollmentRequestUpdateManyWithoutStudioInput>;
  accessRequests?: Maybe<AccessRequestUpdateManyWithoutStudioInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface StudioUpdatestylesInput {
  set?: Maybe<String[] | String>;
}

export interface StudioUpdatecompetitiveLevelsInput {
  set?: Maybe<String[] | String>;
}

export interface StudioUpdateageDivisionsInput {
  set?: Maybe<String[] | String>;
}

export interface MakeupSetUpdateManyWithoutStudioInput {
  create?: Maybe<
    MakeupSetCreateWithoutStudioInput[] | MakeupSetCreateWithoutStudioInput
  >;
  delete?: Maybe<MakeupSetWhereUniqueInput[] | MakeupSetWhereUniqueInput>;
  connect?: Maybe<MakeupSetWhereUniqueInput[] | MakeupSetWhereUniqueInput>;
  set?: Maybe<MakeupSetWhereUniqueInput[] | MakeupSetWhereUniqueInput>;
  disconnect?: Maybe<MakeupSetWhereUniqueInput[] | MakeupSetWhereUniqueInput>;
  update?: Maybe<
    | MakeupSetUpdateWithWhereUniqueWithoutStudioInput[]
    | MakeupSetUpdateWithWhereUniqueWithoutStudioInput
  >;
  upsert?: Maybe<
    | MakeupSetUpsertWithWhereUniqueWithoutStudioInput[]
    | MakeupSetUpsertWithWhereUniqueWithoutStudioInput
  >;
  deleteMany?: Maybe<MakeupSetScalarWhereInput[] | MakeupSetScalarWhereInput>;
  updateMany?: Maybe<
    | MakeupSetUpdateManyWithWhereNestedInput[]
    | MakeupSetUpdateManyWithWhereNestedInput
  >;
}

export interface MakeupSetUpdateWithWhereUniqueWithoutStudioInput {
  where: MakeupSetWhereUniqueInput;
  data: MakeupSetUpdateWithoutStudioDataInput;
}

export interface MakeupSetUpdateWithoutStudioDataInput {
  name?: Maybe<String>;
  lipstick?: Maybe<String>;
  eyeShadow?: Maybe<String>;
  eyeLids?: Maybe<String>;
  eyeCrease?: Maybe<String>;
  eyeLiner?: Maybe<String>;
  eyelashes?: Maybe<String>;
  foundation?: Maybe<String>;
  powder?: Maybe<String>;
  blush?: Maybe<String>;
  bronzer?: Maybe<String>;
  applyToCategories?: Maybe<String>;
  notes?: Maybe<String>;
  danceClasses?: Maybe<DanceClassUpdateManyWithoutMakeupSetInput>;
}

export interface DanceClassUpdateManyWithoutMakeupSetInput {
  create?: Maybe<
    | DanceClassCreateWithoutMakeupSetInput[]
    | DanceClassCreateWithoutMakeupSetInput
  >;
  delete?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
  connect?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
  set?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
  disconnect?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
  update?: Maybe<
    | DanceClassUpdateWithWhereUniqueWithoutMakeupSetInput[]
    | DanceClassUpdateWithWhereUniqueWithoutMakeupSetInput
  >;
  upsert?: Maybe<
    | DanceClassUpsertWithWhereUniqueWithoutMakeupSetInput[]
    | DanceClassUpsertWithWhereUniqueWithoutMakeupSetInput
  >;
  deleteMany?: Maybe<DanceClassScalarWhereInput[] | DanceClassScalarWhereInput>;
  updateMany?: Maybe<
    | DanceClassUpdateManyWithWhereNestedInput[]
    | DanceClassUpdateManyWithWhereNestedInput
  >;
}

export interface DanceClassUpdateWithWhereUniqueWithoutMakeupSetInput {
  where: DanceClassWhereUniqueInput;
  data: DanceClassUpdateWithoutMakeupSetDataInput;
}

export interface DanceClassUpdateWithoutMakeupSetDataInput {
  name?: Maybe<String>;
  studio?: Maybe<StudioUpdateOneRequiredWithoutDanceClassesInput>;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  style?: Maybe<String>;
  tights?: Maybe<String>;
  shoes?: Maybe<String>;
  notes?: Maybe<String>;
  dancers?: Maybe<DancerUpdateManyWithoutDanceClassesInput>;
  size?: Maybe<String>;
  custom?: Maybe<Boolean>;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
  videoUrl?: Maybe<String>;
  videoId?: Maybe<String>;
}

export interface StudioUpdateOneRequiredWithoutDanceClassesInput {
  create?: Maybe<StudioCreateWithoutDanceClassesInput>;
  update?: Maybe<StudioUpdateWithoutDanceClassesDataInput>;
  upsert?: Maybe<StudioUpsertWithoutDanceClassesInput>;
  connect?: Maybe<StudioWhereUniqueInput>;
}

export interface StudioUpdateWithoutDanceClassesDataInput {
  email?: Maybe<String>;
  studioName?: Maybe<String>;
  userType?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  styles?: Maybe<StudioUpdatestylesInput>;
  competitiveLevels?: Maybe<StudioUpdatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioUpdateageDivisionsInput>;
  makeupSets?: Maybe<MakeupSetUpdateManyWithoutStudioInput>;
  hairStyles?: Maybe<HairStyleUpdateManyWithoutStudioInput>;
  dancers?: Maybe<DancerUpdateManyWithoutStudiosInput>;
  events?: Maybe<StudioEventUpdateManyWithoutStudioInput>;
  website?: Maybe<String>;
  enrollmentRequests?: Maybe<EnrollmentRequestUpdateManyWithoutStudioInput>;
  accessRequests?: Maybe<AccessRequestUpdateManyWithoutStudioInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface HairStyleUpdateManyWithoutStudioInput {
  create?: Maybe<
    HairStyleCreateWithoutStudioInput[] | HairStyleCreateWithoutStudioInput
  >;
  delete?: Maybe<HairStyleWhereUniqueInput[] | HairStyleWhereUniqueInput>;
  connect?: Maybe<HairStyleWhereUniqueInput[] | HairStyleWhereUniqueInput>;
  set?: Maybe<HairStyleWhereUniqueInput[] | HairStyleWhereUniqueInput>;
  disconnect?: Maybe<HairStyleWhereUniqueInput[] | HairStyleWhereUniqueInput>;
  update?: Maybe<
    | HairStyleUpdateWithWhereUniqueWithoutStudioInput[]
    | HairStyleUpdateWithWhereUniqueWithoutStudioInput
  >;
  upsert?: Maybe<
    | HairStyleUpsertWithWhereUniqueWithoutStudioInput[]
    | HairStyleUpsertWithWhereUniqueWithoutStudioInput
  >;
  deleteMany?: Maybe<HairStyleScalarWhereInput[] | HairStyleScalarWhereInput>;
  updateMany?: Maybe<
    | HairStyleUpdateManyWithWhereNestedInput[]
    | HairStyleUpdateManyWithWhereNestedInput
  >;
}

export interface HairStyleUpdateWithWhereUniqueWithoutStudioInput {
  where: HairStyleWhereUniqueInput;
  data: HairStyleUpdateWithoutStudioDataInput;
}

export interface HairStyleUpdateWithoutStudioDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
}

export interface HairStyleUpsertWithWhereUniqueWithoutStudioInput {
  where: HairStyleWhereUniqueInput;
  update: HairStyleUpdateWithoutStudioDataInput;
  create: HairStyleCreateWithoutStudioInput;
}

export interface HairStyleScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  AND?: Maybe<HairStyleScalarWhereInput[] | HairStyleScalarWhereInput>;
  OR?: Maybe<HairStyleScalarWhereInput[] | HairStyleScalarWhereInput>;
  NOT?: Maybe<HairStyleScalarWhereInput[] | HairStyleScalarWhereInput>;
}

export interface HairStyleUpdateManyWithWhereNestedInput {
  where: HairStyleScalarWhereInput;
  data: HairStyleUpdateManyDataInput;
}

export interface HairStyleUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
}

export interface DancerUpdateManyWithoutStudiosInput {
  create?: Maybe<
    DancerCreateWithoutStudiosInput[] | DancerCreateWithoutStudiosInput
  >;
  delete?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
  connect?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
  set?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
  disconnect?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
  update?: Maybe<
    | DancerUpdateWithWhereUniqueWithoutStudiosInput[]
    | DancerUpdateWithWhereUniqueWithoutStudiosInput
  >;
  upsert?: Maybe<
    | DancerUpsertWithWhereUniqueWithoutStudiosInput[]
    | DancerUpsertWithWhereUniqueWithoutStudiosInput
  >;
  deleteMany?: Maybe<DancerScalarWhereInput[] | DancerScalarWhereInput>;
  updateMany?: Maybe<
    | DancerUpdateManyWithWhereNestedInput[]
    | DancerUpdateManyWithWhereNestedInput
  >;
}

export interface DancerUpdateWithWhereUniqueWithoutStudiosInput {
  where: DancerWhereUniqueInput;
  data: DancerUpdateWithoutStudiosDataInput;
}

export interface DancerUpdateWithoutStudiosDataInput {
  firstName?: Maybe<String>;
  parent?: Maybe<ParentUpdateOneRequiredWithoutDancersInput>;
  requests?: Maybe<EnrollmentRequestUpdateOneWithoutDancerInput>;
  danceClasses?: Maybe<DanceClassUpdateManyWithoutDancersInput>;
  customRoutines?: Maybe<CustomRoutineUpdateManyWithoutDancersInput>;
  avatar?: Maybe<String>;
  avatarId?: Maybe<String>;
  lastName?: Maybe<String>;
}

export interface EnrollmentRequestUpdateOneWithoutDancerInput {
  create?: Maybe<EnrollmentRequestCreateWithoutDancerInput>;
  update?: Maybe<EnrollmentRequestUpdateWithoutDancerDataInput>;
  upsert?: Maybe<EnrollmentRequestUpsertWithoutDancerInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EnrollmentRequestWhereUniqueInput>;
}

export interface EnrollmentRequestUpdateWithoutDancerDataInput {
  studio?: Maybe<StudioUpdateOneRequiredWithoutEnrollmentRequestsInput>;
  parent?: Maybe<ParentUpdateOneRequiredInput>;
  classesRequested?: Maybe<DanceClassUpdateManyInput>;
}

export interface StudioUpdateOneRequiredWithoutEnrollmentRequestsInput {
  create?: Maybe<StudioCreateWithoutEnrollmentRequestsInput>;
  update?: Maybe<StudioUpdateWithoutEnrollmentRequestsDataInput>;
  upsert?: Maybe<StudioUpsertWithoutEnrollmentRequestsInput>;
  connect?: Maybe<StudioWhereUniqueInput>;
}

export interface StudioUpdateWithoutEnrollmentRequestsDataInput {
  email?: Maybe<String>;
  studioName?: Maybe<String>;
  userType?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  danceClasses?: Maybe<DanceClassUpdateManyWithoutStudioInput>;
  styles?: Maybe<StudioUpdatestylesInput>;
  competitiveLevels?: Maybe<StudioUpdatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioUpdateageDivisionsInput>;
  makeupSets?: Maybe<MakeupSetUpdateManyWithoutStudioInput>;
  hairStyles?: Maybe<HairStyleUpdateManyWithoutStudioInput>;
  dancers?: Maybe<DancerUpdateManyWithoutStudiosInput>;
  events?: Maybe<StudioEventUpdateManyWithoutStudioInput>;
  website?: Maybe<String>;
  accessRequests?: Maybe<AccessRequestUpdateManyWithoutStudioInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface StudioEventUpdateManyWithoutStudioInput {
  create?: Maybe<
    StudioEventCreateWithoutStudioInput[] | StudioEventCreateWithoutStudioInput
  >;
  delete?: Maybe<StudioEventWhereUniqueInput[] | StudioEventWhereUniqueInput>;
  connect?: Maybe<StudioEventWhereUniqueInput[] | StudioEventWhereUniqueInput>;
  set?: Maybe<StudioEventWhereUniqueInput[] | StudioEventWhereUniqueInput>;
  disconnect?: Maybe<
    StudioEventWhereUniqueInput[] | StudioEventWhereUniqueInput
  >;
  update?: Maybe<
    | StudioEventUpdateWithWhereUniqueWithoutStudioInput[]
    | StudioEventUpdateWithWhereUniqueWithoutStudioInput
  >;
  upsert?: Maybe<
    | StudioEventUpsertWithWhereUniqueWithoutStudioInput[]
    | StudioEventUpsertWithWhereUniqueWithoutStudioInput
  >;
  deleteMany?: Maybe<
    StudioEventScalarWhereInput[] | StudioEventScalarWhereInput
  >;
  updateMany?: Maybe<
    | StudioEventUpdateManyWithWhereNestedInput[]
    | StudioEventUpdateManyWithWhereNestedInput
  >;
}

export interface StudioEventUpdateWithWhereUniqueWithoutStudioInput {
  where: StudioEventWhereUniqueInput;
  data: StudioEventUpdateWithoutStudioDataInput;
}

export interface StudioEventUpdateWithoutStudioDataInput {
  name?: Maybe<String>;
  type?: Maybe<String>;
  appliesTo?: Maybe<StudioEventUpdateappliesToInput>;
  beginDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  location?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<String>;
  url?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface StudioEventUpdateappliesToInput {
  set?: Maybe<String[] | String>;
}

export interface StudioEventUpsertWithWhereUniqueWithoutStudioInput {
  where: StudioEventWhereUniqueInput;
  update: StudioEventUpdateWithoutStudioDataInput;
  create: StudioEventCreateWithoutStudioInput;
}

export interface StudioEventScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  beginDate?: Maybe<DateTimeInput>;
  beginDate_not?: Maybe<DateTimeInput>;
  beginDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  beginDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  beginDate_lt?: Maybe<DateTimeInput>;
  beginDate_lte?: Maybe<DateTimeInput>;
  beginDate_gt?: Maybe<DateTimeInput>;
  beginDate_gte?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  address1?: Maybe<String>;
  address1_not?: Maybe<String>;
  address1_in?: Maybe<String[] | String>;
  address1_not_in?: Maybe<String[] | String>;
  address1_lt?: Maybe<String>;
  address1_lte?: Maybe<String>;
  address1_gt?: Maybe<String>;
  address1_gte?: Maybe<String>;
  address1_contains?: Maybe<String>;
  address1_not_contains?: Maybe<String>;
  address1_starts_with?: Maybe<String>;
  address1_not_starts_with?: Maybe<String>;
  address1_ends_with?: Maybe<String>;
  address1_not_ends_with?: Maybe<String>;
  address2?: Maybe<String>;
  address2_not?: Maybe<String>;
  address2_in?: Maybe<String[] | String>;
  address2_not_in?: Maybe<String[] | String>;
  address2_lt?: Maybe<String>;
  address2_lte?: Maybe<String>;
  address2_gt?: Maybe<String>;
  address2_gte?: Maybe<String>;
  address2_contains?: Maybe<String>;
  address2_not_contains?: Maybe<String>;
  address2_starts_with?: Maybe<String>;
  address2_not_starts_with?: Maybe<String>;
  address2_ends_with?: Maybe<String>;
  address2_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zip?: Maybe<String>;
  zip_not?: Maybe<String>;
  zip_in?: Maybe<String[] | String>;
  zip_not_in?: Maybe<String[] | String>;
  zip_lt?: Maybe<String>;
  zip_lte?: Maybe<String>;
  zip_gt?: Maybe<String>;
  zip_gte?: Maybe<String>;
  zip_contains?: Maybe<String>;
  zip_not_contains?: Maybe<String>;
  zip_starts_with?: Maybe<String>;
  zip_not_starts_with?: Maybe<String>;
  zip_ends_with?: Maybe<String>;
  zip_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  AND?: Maybe<StudioEventScalarWhereInput[] | StudioEventScalarWhereInput>;
  OR?: Maybe<StudioEventScalarWhereInput[] | StudioEventScalarWhereInput>;
  NOT?: Maybe<StudioEventScalarWhereInput[] | StudioEventScalarWhereInput>;
}

export interface StudioEventUpdateManyWithWhereNestedInput {
  where: StudioEventScalarWhereInput;
  data: StudioEventUpdateManyDataInput;
}

export interface StudioEventUpdateManyDataInput {
  name?: Maybe<String>;
  type?: Maybe<String>;
  appliesTo?: Maybe<StudioEventUpdateappliesToInput>;
  beginDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  location?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<String>;
  url?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface AccessRequestUpdateManyWithoutStudioInput {
  create?: Maybe<
    | AccessRequestCreateWithoutStudioInput[]
    | AccessRequestCreateWithoutStudioInput
  >;
  delete?: Maybe<
    AccessRequestWhereUniqueInput[] | AccessRequestWhereUniqueInput
  >;
  connect?: Maybe<
    AccessRequestWhereUniqueInput[] | AccessRequestWhereUniqueInput
  >;
  set?: Maybe<AccessRequestWhereUniqueInput[] | AccessRequestWhereUniqueInput>;
  disconnect?: Maybe<
    AccessRequestWhereUniqueInput[] | AccessRequestWhereUniqueInput
  >;
  update?: Maybe<
    | AccessRequestUpdateWithWhereUniqueWithoutStudioInput[]
    | AccessRequestUpdateWithWhereUniqueWithoutStudioInput
  >;
  upsert?: Maybe<
    | AccessRequestUpsertWithWhereUniqueWithoutStudioInput[]
    | AccessRequestUpsertWithWhereUniqueWithoutStudioInput
  >;
  deleteMany?: Maybe<
    AccessRequestScalarWhereInput[] | AccessRequestScalarWhereInput
  >;
}

export interface AccessRequestUpdateWithWhereUniqueWithoutStudioInput {
  where: AccessRequestWhereUniqueInput;
  data: AccessRequestUpdateWithoutStudioDataInput;
}

export interface AccessRequestUpdateWithoutStudioDataInput {
  parent?: Maybe<ParentUpdateOneRequiredInput>;
}

export interface ParentUpdateOneRequiredInput {
  create?: Maybe<ParentCreateInput>;
  update?: Maybe<ParentUpdateDataInput>;
  upsert?: Maybe<ParentUpsertNestedInput>;
  connect?: Maybe<ParentWhereUniqueInput>;
}

export interface ParentUpdateDataInput {
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  userType?: Maybe<String>;
  dancers?: Maybe<DancerUpdateManyWithoutParentInput>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  customRoutines?: Maybe<CustomRoutineUpdateManyWithoutParentInput>;
  studios?: Maybe<StudioUpdateManyInput>;
  accessRequests?: Maybe<ParentUpdateaccessRequestsInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface DancerUpdateManyWithoutParentInput {
  create?: Maybe<
    DancerCreateWithoutParentInput[] | DancerCreateWithoutParentInput
  >;
  delete?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
  connect?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
  set?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
  disconnect?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
  update?: Maybe<
    | DancerUpdateWithWhereUniqueWithoutParentInput[]
    | DancerUpdateWithWhereUniqueWithoutParentInput
  >;
  upsert?: Maybe<
    | DancerUpsertWithWhereUniqueWithoutParentInput[]
    | DancerUpsertWithWhereUniqueWithoutParentInput
  >;
  deleteMany?: Maybe<DancerScalarWhereInput[] | DancerScalarWhereInput>;
  updateMany?: Maybe<
    | DancerUpdateManyWithWhereNestedInput[]
    | DancerUpdateManyWithWhereNestedInput
  >;
}

export interface DancerUpdateWithWhereUniqueWithoutParentInput {
  where: DancerWhereUniqueInput;
  data: DancerUpdateWithoutParentDataInput;
}

export interface DancerUpdateWithoutParentDataInput {
  firstName?: Maybe<String>;
  requests?: Maybe<EnrollmentRequestUpdateOneWithoutDancerInput>;
  danceClasses?: Maybe<DanceClassUpdateManyWithoutDancersInput>;
  customRoutines?: Maybe<CustomRoutineUpdateManyWithoutDancersInput>;
  avatar?: Maybe<String>;
  avatarId?: Maybe<String>;
  lastName?: Maybe<String>;
  studios?: Maybe<StudioUpdateManyWithoutDancersInput>;
}

export interface DanceClassUpdateManyWithoutDancersInput {
  create?: Maybe<
    DanceClassCreateWithoutDancersInput[] | DanceClassCreateWithoutDancersInput
  >;
  delete?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
  connect?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
  set?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
  disconnect?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
  update?: Maybe<
    | DanceClassUpdateWithWhereUniqueWithoutDancersInput[]
    | DanceClassUpdateWithWhereUniqueWithoutDancersInput
  >;
  upsert?: Maybe<
    | DanceClassUpsertWithWhereUniqueWithoutDancersInput[]
    | DanceClassUpsertWithWhereUniqueWithoutDancersInput
  >;
  deleteMany?: Maybe<DanceClassScalarWhereInput[] | DanceClassScalarWhereInput>;
  updateMany?: Maybe<
    | DanceClassUpdateManyWithWhereNestedInput[]
    | DanceClassUpdateManyWithWhereNestedInput
  >;
}

export interface DanceClassUpdateWithWhereUniqueWithoutDancersInput {
  where: DanceClassWhereUniqueInput;
  data: DanceClassUpdateWithoutDancersDataInput;
}

export interface DanceClassUpdateWithoutDancersDataInput {
  name?: Maybe<String>;
  studio?: Maybe<StudioUpdateOneRequiredWithoutDanceClassesInput>;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  style?: Maybe<String>;
  tights?: Maybe<String>;
  shoes?: Maybe<String>;
  notes?: Maybe<String>;
  makeupSet?: Maybe<MakeupSetUpdateOneWithoutDanceClassesInput>;
  size?: Maybe<String>;
  custom?: Maybe<Boolean>;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
  videoUrl?: Maybe<String>;
  videoId?: Maybe<String>;
}

export interface MakeupSetUpdateOneWithoutDanceClassesInput {
  create?: Maybe<MakeupSetCreateWithoutDanceClassesInput>;
  update?: Maybe<MakeupSetUpdateWithoutDanceClassesDataInput>;
  upsert?: Maybe<MakeupSetUpsertWithoutDanceClassesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<MakeupSetWhereUniqueInput>;
}

export interface MakeupSetUpdateWithoutDanceClassesDataInput {
  name?: Maybe<String>;
  studio?: Maybe<StudioUpdateOneRequiredWithoutMakeupSetsInput>;
  lipstick?: Maybe<String>;
  eyeShadow?: Maybe<String>;
  eyeLids?: Maybe<String>;
  eyeCrease?: Maybe<String>;
  eyeLiner?: Maybe<String>;
  eyelashes?: Maybe<String>;
  foundation?: Maybe<String>;
  powder?: Maybe<String>;
  blush?: Maybe<String>;
  bronzer?: Maybe<String>;
  applyToCategories?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface StudioUpdateOneRequiredWithoutMakeupSetsInput {
  create?: Maybe<StudioCreateWithoutMakeupSetsInput>;
  update?: Maybe<StudioUpdateWithoutMakeupSetsDataInput>;
  upsert?: Maybe<StudioUpsertWithoutMakeupSetsInput>;
  connect?: Maybe<StudioWhereUniqueInput>;
}

export interface StudioUpdateWithoutMakeupSetsDataInput {
  email?: Maybe<String>;
  studioName?: Maybe<String>;
  userType?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  danceClasses?: Maybe<DanceClassUpdateManyWithoutStudioInput>;
  styles?: Maybe<StudioUpdatestylesInput>;
  competitiveLevels?: Maybe<StudioUpdatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioUpdateageDivisionsInput>;
  hairStyles?: Maybe<HairStyleUpdateManyWithoutStudioInput>;
  dancers?: Maybe<DancerUpdateManyWithoutStudiosInput>;
  events?: Maybe<StudioEventUpdateManyWithoutStudioInput>;
  website?: Maybe<String>;
  enrollmentRequests?: Maybe<EnrollmentRequestUpdateManyWithoutStudioInput>;
  accessRequests?: Maybe<AccessRequestUpdateManyWithoutStudioInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface EnrollmentRequestUpdateManyWithoutStudioInput {
  create?: Maybe<
    | EnrollmentRequestCreateWithoutStudioInput[]
    | EnrollmentRequestCreateWithoutStudioInput
  >;
  delete?: Maybe<
    EnrollmentRequestWhereUniqueInput[] | EnrollmentRequestWhereUniqueInput
  >;
  connect?: Maybe<
    EnrollmentRequestWhereUniqueInput[] | EnrollmentRequestWhereUniqueInput
  >;
  set?: Maybe<
    EnrollmentRequestWhereUniqueInput[] | EnrollmentRequestWhereUniqueInput
  >;
  disconnect?: Maybe<
    EnrollmentRequestWhereUniqueInput[] | EnrollmentRequestWhereUniqueInput
  >;
  update?: Maybe<
    | EnrollmentRequestUpdateWithWhereUniqueWithoutStudioInput[]
    | EnrollmentRequestUpdateWithWhereUniqueWithoutStudioInput
  >;
  upsert?: Maybe<
    | EnrollmentRequestUpsertWithWhereUniqueWithoutStudioInput[]
    | EnrollmentRequestUpsertWithWhereUniqueWithoutStudioInput
  >;
  deleteMany?: Maybe<
    EnrollmentRequestScalarWhereInput[] | EnrollmentRequestScalarWhereInput
  >;
}

export interface EnrollmentRequestUpdateWithWhereUniqueWithoutStudioInput {
  where: EnrollmentRequestWhereUniqueInput;
  data: EnrollmentRequestUpdateWithoutStudioDataInput;
}

export interface EnrollmentRequestUpdateWithoutStudioDataInput {
  parent?: Maybe<ParentUpdateOneRequiredInput>;
  dancer?: Maybe<DancerUpdateOneRequiredWithoutRequestsInput>;
  classesRequested?: Maybe<DanceClassUpdateManyInput>;
}

export interface DancerUpdateOneRequiredWithoutRequestsInput {
  create?: Maybe<DancerCreateWithoutRequestsInput>;
  update?: Maybe<DancerUpdateWithoutRequestsDataInput>;
  upsert?: Maybe<DancerUpsertWithoutRequestsInput>;
  connect?: Maybe<DancerWhereUniqueInput>;
}

export interface DancerUpdateWithoutRequestsDataInput {
  firstName?: Maybe<String>;
  parent?: Maybe<ParentUpdateOneRequiredWithoutDancersInput>;
  danceClasses?: Maybe<DanceClassUpdateManyWithoutDancersInput>;
  customRoutines?: Maybe<CustomRoutineUpdateManyWithoutDancersInput>;
  avatar?: Maybe<String>;
  avatarId?: Maybe<String>;
  lastName?: Maybe<String>;
  studios?: Maybe<StudioUpdateManyWithoutDancersInput>;
}

export interface CustomRoutineUpdateManyWithoutDancersInput {
  create?: Maybe<
    | CustomRoutineCreateWithoutDancersInput[]
    | CustomRoutineCreateWithoutDancersInput
  >;
  delete?: Maybe<
    CustomRoutineWhereUniqueInput[] | CustomRoutineWhereUniqueInput
  >;
  connect?: Maybe<
    CustomRoutineWhereUniqueInput[] | CustomRoutineWhereUniqueInput
  >;
  set?: Maybe<CustomRoutineWhereUniqueInput[] | CustomRoutineWhereUniqueInput>;
  disconnect?: Maybe<
    CustomRoutineWhereUniqueInput[] | CustomRoutineWhereUniqueInput
  >;
  update?: Maybe<
    | CustomRoutineUpdateWithWhereUniqueWithoutDancersInput[]
    | CustomRoutineUpdateWithWhereUniqueWithoutDancersInput
  >;
  upsert?: Maybe<
    | CustomRoutineUpsertWithWhereUniqueWithoutDancersInput[]
    | CustomRoutineUpsertWithWhereUniqueWithoutDancersInput
  >;
  deleteMany?: Maybe<
    CustomRoutineScalarWhereInput[] | CustomRoutineScalarWhereInput
  >;
  updateMany?: Maybe<
    | CustomRoutineUpdateManyWithWhereNestedInput[]
    | CustomRoutineUpdateManyWithWhereNestedInput
  >;
}

export interface CustomRoutineUpdateWithWhereUniqueWithoutDancersInput {
  where: CustomRoutineWhereUniqueInput;
  data: CustomRoutineUpdateWithoutDancersDataInput;
}

export interface CustomRoutineUpdateWithoutDancersDataInput {
  custom?: Maybe<Boolean>;
  name?: Maybe<String>;
  studio?: Maybe<StudioUpdateOneInput>;
  parent?: Maybe<ParentUpdateOneRequiredWithoutCustomRoutinesInput>;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  style?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  shoes?: Maybe<String>;
  tights?: Maybe<String>;
  notes?: Maybe<String>;
  type?: Maybe<String>;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
}

export interface ParentUpdateOneRequiredWithoutCustomRoutinesInput {
  create?: Maybe<ParentCreateWithoutCustomRoutinesInput>;
  update?: Maybe<ParentUpdateWithoutCustomRoutinesDataInput>;
  upsert?: Maybe<ParentUpsertWithoutCustomRoutinesInput>;
  connect?: Maybe<ParentWhereUniqueInput>;
}

export interface ParentUpdateWithoutCustomRoutinesDataInput {
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  userType?: Maybe<String>;
  dancers?: Maybe<DancerUpdateManyWithoutParentInput>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  studios?: Maybe<StudioUpdateManyInput>;
  accessRequests?: Maybe<ParentUpdateaccessRequestsInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface StudioUpdateManyInput {
  create?: Maybe<StudioCreateInput[] | StudioCreateInput>;
  update?: Maybe<
    | StudioUpdateWithWhereUniqueNestedInput[]
    | StudioUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | StudioUpsertWithWhereUniqueNestedInput[]
    | StudioUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<StudioWhereUniqueInput[] | StudioWhereUniqueInput>;
  connect?: Maybe<StudioWhereUniqueInput[] | StudioWhereUniqueInput>;
  set?: Maybe<StudioWhereUniqueInput[] | StudioWhereUniqueInput>;
  disconnect?: Maybe<StudioWhereUniqueInput[] | StudioWhereUniqueInput>;
  deleteMany?: Maybe<StudioScalarWhereInput[] | StudioScalarWhereInput>;
  updateMany?: Maybe<
    | StudioUpdateManyWithWhereNestedInput[]
    | StudioUpdateManyWithWhereNestedInput
  >;
}

export interface StudioUpdateWithWhereUniqueNestedInput {
  where: StudioWhereUniqueInput;
  data: StudioUpdateDataInput;
}

export interface StudioUpsertWithWhereUniqueNestedInput {
  where: StudioWhereUniqueInput;
  update: StudioUpdateDataInput;
  create: StudioCreateInput;
}

export interface StudioScalarWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  studioName?: Maybe<String>;
  studioName_not?: Maybe<String>;
  studioName_in?: Maybe<String[] | String>;
  studioName_not_in?: Maybe<String[] | String>;
  studioName_lt?: Maybe<String>;
  studioName_lte?: Maybe<String>;
  studioName_gt?: Maybe<String>;
  studioName_gte?: Maybe<String>;
  studioName_contains?: Maybe<String>;
  studioName_not_contains?: Maybe<String>;
  studioName_starts_with?: Maybe<String>;
  studioName_not_starts_with?: Maybe<String>;
  studioName_ends_with?: Maybe<String>;
  studioName_not_ends_with?: Maybe<String>;
  userType?: Maybe<String>;
  userType_not?: Maybe<String>;
  userType_in?: Maybe<String[] | String>;
  userType_not_in?: Maybe<String[] | String>;
  userType_lt?: Maybe<String>;
  userType_lte?: Maybe<String>;
  userType_gt?: Maybe<String>;
  userType_gte?: Maybe<String>;
  userType_contains?: Maybe<String>;
  userType_not_contains?: Maybe<String>;
  userType_starts_with?: Maybe<String>;
  userType_not_starts_with?: Maybe<String>;
  userType_ends_with?: Maybe<String>;
  userType_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetToken_not?: Maybe<String>;
  resetToken_in?: Maybe<String[] | String>;
  resetToken_not_in?: Maybe<String[] | String>;
  resetToken_lt?: Maybe<String>;
  resetToken_lte?: Maybe<String>;
  resetToken_gt?: Maybe<String>;
  resetToken_gte?: Maybe<String>;
  resetToken_contains?: Maybe<String>;
  resetToken_not_contains?: Maybe<String>;
  resetToken_starts_with?: Maybe<String>;
  resetToken_not_starts_with?: Maybe<String>;
  resetToken_ends_with?: Maybe<String>;
  resetToken_not_ends_with?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  resetTokenExpiry_not?: Maybe<Float>;
  resetTokenExpiry_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_not_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_lt?: Maybe<Float>;
  resetTokenExpiry_lte?: Maybe<Float>;
  resetTokenExpiry_gt?: Maybe<Float>;
  resetTokenExpiry_gte?: Maybe<Float>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  agreeToTerms?: Maybe<DateTimeInput>;
  agreeToTerms_not?: Maybe<DateTimeInput>;
  agreeToTerms_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  agreeToTerms_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  agreeToTerms_lt?: Maybe<DateTimeInput>;
  agreeToTerms_lte?: Maybe<DateTimeInput>;
  agreeToTerms_gt?: Maybe<DateTimeInput>;
  agreeToTerms_gte?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
  readPrivacy_not?: Maybe<DateTimeInput>;
  readPrivacy_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  readPrivacy_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  readPrivacy_lt?: Maybe<DateTimeInput>;
  readPrivacy_lte?: Maybe<DateTimeInput>;
  readPrivacy_gt?: Maybe<DateTimeInput>;
  readPrivacy_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StudioScalarWhereInput[] | StudioScalarWhereInput>;
  OR?: Maybe<StudioScalarWhereInput[] | StudioScalarWhereInput>;
  NOT?: Maybe<StudioScalarWhereInput[] | StudioScalarWhereInput>;
}

export interface StudioUpdateManyWithWhereNestedInput {
  where: StudioScalarWhereInput;
  data: StudioUpdateManyDataInput;
}

export interface StudioUpdateManyDataInput {
  email?: Maybe<String>;
  studioName?: Maybe<String>;
  userType?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  styles?: Maybe<StudioUpdatestylesInput>;
  competitiveLevels?: Maybe<StudioUpdatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioUpdateageDivisionsInput>;
  website?: Maybe<String>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface ParentUpdateaccessRequestsInput {
  set?: Maybe<ID_Input[] | ID_Input>;
}

export interface ParentUpsertWithoutCustomRoutinesInput {
  update: ParentUpdateWithoutCustomRoutinesDataInput;
  create: ParentCreateWithoutCustomRoutinesInput;
}

export interface CustomRoutineUpsertWithWhereUniqueWithoutDancersInput {
  where: CustomRoutineWhereUniqueInput;
  update: CustomRoutineUpdateWithoutDancersDataInput;
  create: CustomRoutineCreateWithoutDancersInput;
}

export interface CustomRoutineScalarWhereInput {
  custom?: Maybe<Boolean>;
  custom_not?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  music?: Maybe<String>;
  music_not?: Maybe<String>;
  music_in?: Maybe<String[] | String>;
  music_not_in?: Maybe<String[] | String>;
  music_lt?: Maybe<String>;
  music_lte?: Maybe<String>;
  music_gt?: Maybe<String>;
  music_gte?: Maybe<String>;
  music_contains?: Maybe<String>;
  music_not_contains?: Maybe<String>;
  music_starts_with?: Maybe<String>;
  music_not_starts_with?: Maybe<String>;
  music_ends_with?: Maybe<String>;
  music_not_ends_with?: Maybe<String>;
  musicId?: Maybe<String>;
  musicId_not?: Maybe<String>;
  musicId_in?: Maybe<String[] | String>;
  musicId_not_in?: Maybe<String[] | String>;
  musicId_lt?: Maybe<String>;
  musicId_lte?: Maybe<String>;
  musicId_gt?: Maybe<String>;
  musicId_gte?: Maybe<String>;
  musicId_contains?: Maybe<String>;
  musicId_not_contains?: Maybe<String>;
  musicId_starts_with?: Maybe<String>;
  musicId_not_starts_with?: Maybe<String>;
  musicId_ends_with?: Maybe<String>;
  musicId_not_ends_with?: Maybe<String>;
  style?: Maybe<String>;
  style_not?: Maybe<String>;
  style_in?: Maybe<String[] | String>;
  style_not_in?: Maybe<String[] | String>;
  style_lt?: Maybe<String>;
  style_lte?: Maybe<String>;
  style_gt?: Maybe<String>;
  style_gte?: Maybe<String>;
  style_contains?: Maybe<String>;
  style_not_contains?: Maybe<String>;
  style_starts_with?: Maybe<String>;
  style_not_starts_with?: Maybe<String>;
  style_ends_with?: Maybe<String>;
  style_not_ends_with?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  competitiveLevel_not?: Maybe<String>;
  competitiveLevel_in?: Maybe<String[] | String>;
  competitiveLevel_not_in?: Maybe<String[] | String>;
  competitiveLevel_lt?: Maybe<String>;
  competitiveLevel_lte?: Maybe<String>;
  competitiveLevel_gt?: Maybe<String>;
  competitiveLevel_gte?: Maybe<String>;
  competitiveLevel_contains?: Maybe<String>;
  competitiveLevel_not_contains?: Maybe<String>;
  competitiveLevel_starts_with?: Maybe<String>;
  competitiveLevel_not_starts_with?: Maybe<String>;
  competitiveLevel_ends_with?: Maybe<String>;
  competitiveLevel_not_ends_with?: Maybe<String>;
  ageDivision?: Maybe<String>;
  ageDivision_not?: Maybe<String>;
  ageDivision_in?: Maybe<String[] | String>;
  ageDivision_not_in?: Maybe<String[] | String>;
  ageDivision_lt?: Maybe<String>;
  ageDivision_lte?: Maybe<String>;
  ageDivision_gt?: Maybe<String>;
  ageDivision_gte?: Maybe<String>;
  ageDivision_contains?: Maybe<String>;
  ageDivision_not_contains?: Maybe<String>;
  ageDivision_starts_with?: Maybe<String>;
  ageDivision_not_starts_with?: Maybe<String>;
  ageDivision_ends_with?: Maybe<String>;
  ageDivision_not_ends_with?: Maybe<String>;
  performanceName?: Maybe<String>;
  performanceName_not?: Maybe<String>;
  performanceName_in?: Maybe<String[] | String>;
  performanceName_not_in?: Maybe<String[] | String>;
  performanceName_lt?: Maybe<String>;
  performanceName_lte?: Maybe<String>;
  performanceName_gt?: Maybe<String>;
  performanceName_gte?: Maybe<String>;
  performanceName_contains?: Maybe<String>;
  performanceName_not_contains?: Maybe<String>;
  performanceName_starts_with?: Maybe<String>;
  performanceName_not_starts_with?: Maybe<String>;
  performanceName_ends_with?: Maybe<String>;
  performanceName_not_ends_with?: Maybe<String>;
  day?: Maybe<String>;
  day_not?: Maybe<String>;
  day_in?: Maybe<String[] | String>;
  day_not_in?: Maybe<String[] | String>;
  day_lt?: Maybe<String>;
  day_lte?: Maybe<String>;
  day_gt?: Maybe<String>;
  day_gte?: Maybe<String>;
  day_contains?: Maybe<String>;
  day_not_contains?: Maybe<String>;
  day_starts_with?: Maybe<String>;
  day_not_starts_with?: Maybe<String>;
  day_ends_with?: Maybe<String>;
  day_not_ends_with?: Maybe<String>;
  startTime?: Maybe<String>;
  startTime_not?: Maybe<String>;
  startTime_in?: Maybe<String[] | String>;
  startTime_not_in?: Maybe<String[] | String>;
  startTime_lt?: Maybe<String>;
  startTime_lte?: Maybe<String>;
  startTime_gt?: Maybe<String>;
  startTime_gte?: Maybe<String>;
  startTime_contains?: Maybe<String>;
  startTime_not_contains?: Maybe<String>;
  startTime_starts_with?: Maybe<String>;
  startTime_not_starts_with?: Maybe<String>;
  startTime_ends_with?: Maybe<String>;
  startTime_not_ends_with?: Maybe<String>;
  endTime?: Maybe<String>;
  endTime_not?: Maybe<String>;
  endTime_in?: Maybe<String[] | String>;
  endTime_not_in?: Maybe<String[] | String>;
  endTime_lt?: Maybe<String>;
  endTime_lte?: Maybe<String>;
  endTime_gt?: Maybe<String>;
  endTime_gte?: Maybe<String>;
  endTime_contains?: Maybe<String>;
  endTime_not_contains?: Maybe<String>;
  endTime_starts_with?: Maybe<String>;
  endTime_not_starts_with?: Maybe<String>;
  endTime_ends_with?: Maybe<String>;
  endTime_not_ends_with?: Maybe<String>;
  shoes?: Maybe<String>;
  shoes_not?: Maybe<String>;
  shoes_in?: Maybe<String[] | String>;
  shoes_not_in?: Maybe<String[] | String>;
  shoes_lt?: Maybe<String>;
  shoes_lte?: Maybe<String>;
  shoes_gt?: Maybe<String>;
  shoes_gte?: Maybe<String>;
  shoes_contains?: Maybe<String>;
  shoes_not_contains?: Maybe<String>;
  shoes_starts_with?: Maybe<String>;
  shoes_not_starts_with?: Maybe<String>;
  shoes_ends_with?: Maybe<String>;
  shoes_not_ends_with?: Maybe<String>;
  tights?: Maybe<String>;
  tights_not?: Maybe<String>;
  tights_in?: Maybe<String[] | String>;
  tights_not_in?: Maybe<String[] | String>;
  tights_lt?: Maybe<String>;
  tights_lte?: Maybe<String>;
  tights_gt?: Maybe<String>;
  tights_gte?: Maybe<String>;
  tights_contains?: Maybe<String>;
  tights_not_contains?: Maybe<String>;
  tights_starts_with?: Maybe<String>;
  tights_not_starts_with?: Maybe<String>;
  tights_ends_with?: Maybe<String>;
  tights_not_ends_with?: Maybe<String>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  entryNumber?: Maybe<String>;
  entryNumber_not?: Maybe<String>;
  entryNumber_in?: Maybe<String[] | String>;
  entryNumber_not_in?: Maybe<String[] | String>;
  entryNumber_lt?: Maybe<String>;
  entryNumber_lte?: Maybe<String>;
  entryNumber_gt?: Maybe<String>;
  entryNumber_gte?: Maybe<String>;
  entryNumber_contains?: Maybe<String>;
  entryNumber_not_contains?: Maybe<String>;
  entryNumber_starts_with?: Maybe<String>;
  entryNumber_not_starts_with?: Maybe<String>;
  entryNumber_ends_with?: Maybe<String>;
  entryNumber_not_ends_with?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryTime_not?: Maybe<String>;
  entryTime_in?: Maybe<String[] | String>;
  entryTime_not_in?: Maybe<String[] | String>;
  entryTime_lt?: Maybe<String>;
  entryTime_lte?: Maybe<String>;
  entryTime_gt?: Maybe<String>;
  entryTime_gte?: Maybe<String>;
  entryTime_contains?: Maybe<String>;
  entryTime_not_contains?: Maybe<String>;
  entryTime_starts_with?: Maybe<String>;
  entryTime_not_starts_with?: Maybe<String>;
  entryTime_ends_with?: Maybe<String>;
  entryTime_not_ends_with?: Maybe<String>;
  entryDay?: Maybe<String>;
  entryDay_not?: Maybe<String>;
  entryDay_in?: Maybe<String[] | String>;
  entryDay_not_in?: Maybe<String[] | String>;
  entryDay_lt?: Maybe<String>;
  entryDay_lte?: Maybe<String>;
  entryDay_gt?: Maybe<String>;
  entryDay_gte?: Maybe<String>;
  entryDay_contains?: Maybe<String>;
  entryDay_not_contains?: Maybe<String>;
  entryDay_starts_with?: Maybe<String>;
  entryDay_not_starts_with?: Maybe<String>;
  entryDay_ends_with?: Maybe<String>;
  entryDay_not_ends_with?: Maybe<String>;
  AND?: Maybe<CustomRoutineScalarWhereInput[] | CustomRoutineScalarWhereInput>;
  OR?: Maybe<CustomRoutineScalarWhereInput[] | CustomRoutineScalarWhereInput>;
  NOT?: Maybe<CustomRoutineScalarWhereInput[] | CustomRoutineScalarWhereInput>;
}

export interface CustomRoutineUpdateManyWithWhereNestedInput {
  where: CustomRoutineScalarWhereInput;
  data: CustomRoutineUpdateManyDataInput;
}

export interface CustomRoutineUpdateManyDataInput {
  custom?: Maybe<Boolean>;
  name?: Maybe<String>;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  style?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  shoes?: Maybe<String>;
  tights?: Maybe<String>;
  notes?: Maybe<String>;
  type?: Maybe<String>;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
}

export interface StudioUpdateManyWithoutDancersInput {
  create?: Maybe<
    StudioCreateWithoutDancersInput[] | StudioCreateWithoutDancersInput
  >;
  delete?: Maybe<StudioWhereUniqueInput[] | StudioWhereUniqueInput>;
  connect?: Maybe<StudioWhereUniqueInput[] | StudioWhereUniqueInput>;
  set?: Maybe<StudioWhereUniqueInput[] | StudioWhereUniqueInput>;
  disconnect?: Maybe<StudioWhereUniqueInput[] | StudioWhereUniqueInput>;
  update?: Maybe<
    | StudioUpdateWithWhereUniqueWithoutDancersInput[]
    | StudioUpdateWithWhereUniqueWithoutDancersInput
  >;
  upsert?: Maybe<
    | StudioUpsertWithWhereUniqueWithoutDancersInput[]
    | StudioUpsertWithWhereUniqueWithoutDancersInput
  >;
  deleteMany?: Maybe<StudioScalarWhereInput[] | StudioScalarWhereInput>;
  updateMany?: Maybe<
    | StudioUpdateManyWithWhereNestedInput[]
    | StudioUpdateManyWithWhereNestedInput
  >;
}

export interface StudioUpdateWithWhereUniqueWithoutDancersInput {
  where: StudioWhereUniqueInput;
  data: StudioUpdateWithoutDancersDataInput;
}

export interface StudioUpdateWithoutDancersDataInput {
  email?: Maybe<String>;
  studioName?: Maybe<String>;
  userType?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  danceClasses?: Maybe<DanceClassUpdateManyWithoutStudioInput>;
  styles?: Maybe<StudioUpdatestylesInput>;
  competitiveLevels?: Maybe<StudioUpdatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioUpdateageDivisionsInput>;
  makeupSets?: Maybe<MakeupSetUpdateManyWithoutStudioInput>;
  hairStyles?: Maybe<HairStyleUpdateManyWithoutStudioInput>;
  events?: Maybe<StudioEventUpdateManyWithoutStudioInput>;
  website?: Maybe<String>;
  enrollmentRequests?: Maybe<EnrollmentRequestUpdateManyWithoutStudioInput>;
  accessRequests?: Maybe<AccessRequestUpdateManyWithoutStudioInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface StudioUpsertWithWhereUniqueWithoutDancersInput {
  where: StudioWhereUniqueInput;
  update: StudioUpdateWithoutDancersDataInput;
  create: StudioCreateWithoutDancersInput;
}

export interface DancerUpsertWithoutRequestsInput {
  update: DancerUpdateWithoutRequestsDataInput;
  create: DancerCreateWithoutRequestsInput;
}

export interface DanceClassUpdateManyInput {
  create?: Maybe<DanceClassCreateInput[] | DanceClassCreateInput>;
  update?: Maybe<
    | DanceClassUpdateWithWhereUniqueNestedInput[]
    | DanceClassUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | DanceClassUpsertWithWhereUniqueNestedInput[]
    | DanceClassUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
  connect?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
  set?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
  disconnect?: Maybe<DanceClassWhereUniqueInput[] | DanceClassWhereUniqueInput>;
  deleteMany?: Maybe<DanceClassScalarWhereInput[] | DanceClassScalarWhereInput>;
  updateMany?: Maybe<
    | DanceClassUpdateManyWithWhereNestedInput[]
    | DanceClassUpdateManyWithWhereNestedInput
  >;
}

export interface DanceClassUpdateWithWhereUniqueNestedInput {
  where: DanceClassWhereUniqueInput;
  data: DanceClassUpdateDataInput;
}

export interface DanceClassUpdateDataInput {
  name?: Maybe<String>;
  studio?: Maybe<StudioUpdateOneRequiredWithoutDanceClassesInput>;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  style?: Maybe<String>;
  tights?: Maybe<String>;
  shoes?: Maybe<String>;
  notes?: Maybe<String>;
  dancers?: Maybe<DancerUpdateManyWithoutDanceClassesInput>;
  makeupSet?: Maybe<MakeupSetUpdateOneWithoutDanceClassesInput>;
  size?: Maybe<String>;
  custom?: Maybe<Boolean>;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
  videoUrl?: Maybe<String>;
  videoId?: Maybe<String>;
}

export interface DanceClassUpsertWithWhereUniqueNestedInput {
  where: DanceClassWhereUniqueInput;
  update: DanceClassUpdateDataInput;
  create: DanceClassCreateInput;
}

export interface DanceClassScalarWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  music?: Maybe<String>;
  music_not?: Maybe<String>;
  music_in?: Maybe<String[] | String>;
  music_not_in?: Maybe<String[] | String>;
  music_lt?: Maybe<String>;
  music_lte?: Maybe<String>;
  music_gt?: Maybe<String>;
  music_gte?: Maybe<String>;
  music_contains?: Maybe<String>;
  music_not_contains?: Maybe<String>;
  music_starts_with?: Maybe<String>;
  music_not_starts_with?: Maybe<String>;
  music_ends_with?: Maybe<String>;
  music_not_ends_with?: Maybe<String>;
  musicId?: Maybe<String>;
  musicId_not?: Maybe<String>;
  musicId_in?: Maybe<String[] | String>;
  musicId_not_in?: Maybe<String[] | String>;
  musicId_lt?: Maybe<String>;
  musicId_lte?: Maybe<String>;
  musicId_gt?: Maybe<String>;
  musicId_gte?: Maybe<String>;
  musicId_contains?: Maybe<String>;
  musicId_not_contains?: Maybe<String>;
  musicId_starts_with?: Maybe<String>;
  musicId_not_starts_with?: Maybe<String>;
  musicId_ends_with?: Maybe<String>;
  musicId_not_ends_with?: Maybe<String>;
  performanceName?: Maybe<String>;
  performanceName_not?: Maybe<String>;
  performanceName_in?: Maybe<String[] | String>;
  performanceName_not_in?: Maybe<String[] | String>;
  performanceName_lt?: Maybe<String>;
  performanceName_lte?: Maybe<String>;
  performanceName_gt?: Maybe<String>;
  performanceName_gte?: Maybe<String>;
  performanceName_contains?: Maybe<String>;
  performanceName_not_contains?: Maybe<String>;
  performanceName_starts_with?: Maybe<String>;
  performanceName_not_starts_with?: Maybe<String>;
  performanceName_ends_with?: Maybe<String>;
  performanceName_not_ends_with?: Maybe<String>;
  day?: Maybe<String>;
  day_not?: Maybe<String>;
  day_in?: Maybe<String[] | String>;
  day_not_in?: Maybe<String[] | String>;
  day_lt?: Maybe<String>;
  day_lte?: Maybe<String>;
  day_gt?: Maybe<String>;
  day_gte?: Maybe<String>;
  day_contains?: Maybe<String>;
  day_not_contains?: Maybe<String>;
  day_starts_with?: Maybe<String>;
  day_not_starts_with?: Maybe<String>;
  day_ends_with?: Maybe<String>;
  day_not_ends_with?: Maybe<String>;
  startTime?: Maybe<String>;
  startTime_not?: Maybe<String>;
  startTime_in?: Maybe<String[] | String>;
  startTime_not_in?: Maybe<String[] | String>;
  startTime_lt?: Maybe<String>;
  startTime_lte?: Maybe<String>;
  startTime_gt?: Maybe<String>;
  startTime_gte?: Maybe<String>;
  startTime_contains?: Maybe<String>;
  startTime_not_contains?: Maybe<String>;
  startTime_starts_with?: Maybe<String>;
  startTime_not_starts_with?: Maybe<String>;
  startTime_ends_with?: Maybe<String>;
  startTime_not_ends_with?: Maybe<String>;
  endTime?: Maybe<String>;
  endTime_not?: Maybe<String>;
  endTime_in?: Maybe<String[] | String>;
  endTime_not_in?: Maybe<String[] | String>;
  endTime_lt?: Maybe<String>;
  endTime_lte?: Maybe<String>;
  endTime_gt?: Maybe<String>;
  endTime_gte?: Maybe<String>;
  endTime_contains?: Maybe<String>;
  endTime_not_contains?: Maybe<String>;
  endTime_starts_with?: Maybe<String>;
  endTime_not_starts_with?: Maybe<String>;
  endTime_ends_with?: Maybe<String>;
  endTime_not_ends_with?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  competitiveLevel_not?: Maybe<String>;
  competitiveLevel_in?: Maybe<String[] | String>;
  competitiveLevel_not_in?: Maybe<String[] | String>;
  competitiveLevel_lt?: Maybe<String>;
  competitiveLevel_lte?: Maybe<String>;
  competitiveLevel_gt?: Maybe<String>;
  competitiveLevel_gte?: Maybe<String>;
  competitiveLevel_contains?: Maybe<String>;
  competitiveLevel_not_contains?: Maybe<String>;
  competitiveLevel_starts_with?: Maybe<String>;
  competitiveLevel_not_starts_with?: Maybe<String>;
  competitiveLevel_ends_with?: Maybe<String>;
  competitiveLevel_not_ends_with?: Maybe<String>;
  ageDivision?: Maybe<String>;
  ageDivision_not?: Maybe<String>;
  ageDivision_in?: Maybe<String[] | String>;
  ageDivision_not_in?: Maybe<String[] | String>;
  ageDivision_lt?: Maybe<String>;
  ageDivision_lte?: Maybe<String>;
  ageDivision_gt?: Maybe<String>;
  ageDivision_gte?: Maybe<String>;
  ageDivision_contains?: Maybe<String>;
  ageDivision_not_contains?: Maybe<String>;
  ageDivision_starts_with?: Maybe<String>;
  ageDivision_not_starts_with?: Maybe<String>;
  ageDivision_ends_with?: Maybe<String>;
  ageDivision_not_ends_with?: Maybe<String>;
  style?: Maybe<String>;
  style_not?: Maybe<String>;
  style_in?: Maybe<String[] | String>;
  style_not_in?: Maybe<String[] | String>;
  style_lt?: Maybe<String>;
  style_lte?: Maybe<String>;
  style_gt?: Maybe<String>;
  style_gte?: Maybe<String>;
  style_contains?: Maybe<String>;
  style_not_contains?: Maybe<String>;
  style_starts_with?: Maybe<String>;
  style_not_starts_with?: Maybe<String>;
  style_ends_with?: Maybe<String>;
  style_not_ends_with?: Maybe<String>;
  tights?: Maybe<String>;
  tights_not?: Maybe<String>;
  tights_in?: Maybe<String[] | String>;
  tights_not_in?: Maybe<String[] | String>;
  tights_lt?: Maybe<String>;
  tights_lte?: Maybe<String>;
  tights_gt?: Maybe<String>;
  tights_gte?: Maybe<String>;
  tights_contains?: Maybe<String>;
  tights_not_contains?: Maybe<String>;
  tights_starts_with?: Maybe<String>;
  tights_not_starts_with?: Maybe<String>;
  tights_ends_with?: Maybe<String>;
  tights_not_ends_with?: Maybe<String>;
  shoes?: Maybe<String>;
  shoes_not?: Maybe<String>;
  shoes_in?: Maybe<String[] | String>;
  shoes_not_in?: Maybe<String[] | String>;
  shoes_lt?: Maybe<String>;
  shoes_lte?: Maybe<String>;
  shoes_gt?: Maybe<String>;
  shoes_gte?: Maybe<String>;
  shoes_contains?: Maybe<String>;
  shoes_not_contains?: Maybe<String>;
  shoes_starts_with?: Maybe<String>;
  shoes_not_starts_with?: Maybe<String>;
  shoes_ends_with?: Maybe<String>;
  shoes_not_ends_with?: Maybe<String>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  size?: Maybe<String>;
  size_not?: Maybe<String>;
  size_in?: Maybe<String[] | String>;
  size_not_in?: Maybe<String[] | String>;
  size_lt?: Maybe<String>;
  size_lte?: Maybe<String>;
  size_gt?: Maybe<String>;
  size_gte?: Maybe<String>;
  size_contains?: Maybe<String>;
  size_not_contains?: Maybe<String>;
  size_starts_with?: Maybe<String>;
  size_not_starts_with?: Maybe<String>;
  size_ends_with?: Maybe<String>;
  size_not_ends_with?: Maybe<String>;
  custom?: Maybe<Boolean>;
  custom_not?: Maybe<Boolean>;
  entryNumber?: Maybe<String>;
  entryNumber_not?: Maybe<String>;
  entryNumber_in?: Maybe<String[] | String>;
  entryNumber_not_in?: Maybe<String[] | String>;
  entryNumber_lt?: Maybe<String>;
  entryNumber_lte?: Maybe<String>;
  entryNumber_gt?: Maybe<String>;
  entryNumber_gte?: Maybe<String>;
  entryNumber_contains?: Maybe<String>;
  entryNumber_not_contains?: Maybe<String>;
  entryNumber_starts_with?: Maybe<String>;
  entryNumber_not_starts_with?: Maybe<String>;
  entryNumber_ends_with?: Maybe<String>;
  entryNumber_not_ends_with?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryTime_not?: Maybe<String>;
  entryTime_in?: Maybe<String[] | String>;
  entryTime_not_in?: Maybe<String[] | String>;
  entryTime_lt?: Maybe<String>;
  entryTime_lte?: Maybe<String>;
  entryTime_gt?: Maybe<String>;
  entryTime_gte?: Maybe<String>;
  entryTime_contains?: Maybe<String>;
  entryTime_not_contains?: Maybe<String>;
  entryTime_starts_with?: Maybe<String>;
  entryTime_not_starts_with?: Maybe<String>;
  entryTime_ends_with?: Maybe<String>;
  entryTime_not_ends_with?: Maybe<String>;
  entryDay?: Maybe<String>;
  entryDay_not?: Maybe<String>;
  entryDay_in?: Maybe<String[] | String>;
  entryDay_not_in?: Maybe<String[] | String>;
  entryDay_lt?: Maybe<String>;
  entryDay_lte?: Maybe<String>;
  entryDay_gt?: Maybe<String>;
  entryDay_gte?: Maybe<String>;
  entryDay_contains?: Maybe<String>;
  entryDay_not_contains?: Maybe<String>;
  entryDay_starts_with?: Maybe<String>;
  entryDay_not_starts_with?: Maybe<String>;
  entryDay_ends_with?: Maybe<String>;
  entryDay_not_ends_with?: Maybe<String>;
  videoUrl?: Maybe<String>;
  videoUrl_not?: Maybe<String>;
  videoUrl_in?: Maybe<String[] | String>;
  videoUrl_not_in?: Maybe<String[] | String>;
  videoUrl_lt?: Maybe<String>;
  videoUrl_lte?: Maybe<String>;
  videoUrl_gt?: Maybe<String>;
  videoUrl_gte?: Maybe<String>;
  videoUrl_contains?: Maybe<String>;
  videoUrl_not_contains?: Maybe<String>;
  videoUrl_starts_with?: Maybe<String>;
  videoUrl_not_starts_with?: Maybe<String>;
  videoUrl_ends_with?: Maybe<String>;
  videoUrl_not_ends_with?: Maybe<String>;
  videoId?: Maybe<String>;
  videoId_not?: Maybe<String>;
  videoId_in?: Maybe<String[] | String>;
  videoId_not_in?: Maybe<String[] | String>;
  videoId_lt?: Maybe<String>;
  videoId_lte?: Maybe<String>;
  videoId_gt?: Maybe<String>;
  videoId_gte?: Maybe<String>;
  videoId_contains?: Maybe<String>;
  videoId_not_contains?: Maybe<String>;
  videoId_starts_with?: Maybe<String>;
  videoId_not_starts_with?: Maybe<String>;
  videoId_ends_with?: Maybe<String>;
  videoId_not_ends_with?: Maybe<String>;
  AND?: Maybe<DanceClassScalarWhereInput[] | DanceClassScalarWhereInput>;
  OR?: Maybe<DanceClassScalarWhereInput[] | DanceClassScalarWhereInput>;
  NOT?: Maybe<DanceClassScalarWhereInput[] | DanceClassScalarWhereInput>;
}

export interface DanceClassUpdateManyWithWhereNestedInput {
  where: DanceClassScalarWhereInput;
  data: DanceClassUpdateManyDataInput;
}

export interface DanceClassUpdateManyDataInput {
  name?: Maybe<String>;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  style?: Maybe<String>;
  tights?: Maybe<String>;
  shoes?: Maybe<String>;
  notes?: Maybe<String>;
  size?: Maybe<String>;
  custom?: Maybe<Boolean>;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
  videoUrl?: Maybe<String>;
  videoId?: Maybe<String>;
}

export interface EnrollmentRequestUpsertWithWhereUniqueWithoutStudioInput {
  where: EnrollmentRequestWhereUniqueInput;
  update: EnrollmentRequestUpdateWithoutStudioDataInput;
  create: EnrollmentRequestCreateWithoutStudioInput;
}

export interface EnrollmentRequestScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    EnrollmentRequestScalarWhereInput[] | EnrollmentRequestScalarWhereInput
  >;
  OR?: Maybe<
    EnrollmentRequestScalarWhereInput[] | EnrollmentRequestScalarWhereInput
  >;
  NOT?: Maybe<
    EnrollmentRequestScalarWhereInput[] | EnrollmentRequestScalarWhereInput
  >;
}

export interface StudioUpsertWithoutMakeupSetsInput {
  update: StudioUpdateWithoutMakeupSetsDataInput;
  create: StudioCreateWithoutMakeupSetsInput;
}

export interface MakeupSetUpsertWithoutDanceClassesInput {
  update: MakeupSetUpdateWithoutDanceClassesDataInput;
  create: MakeupSetCreateWithoutDanceClassesInput;
}

export interface DanceClassUpsertWithWhereUniqueWithoutDancersInput {
  where: DanceClassWhereUniqueInput;
  update: DanceClassUpdateWithoutDancersDataInput;
  create: DanceClassCreateWithoutDancersInput;
}

export interface DancerUpsertWithWhereUniqueWithoutParentInput {
  where: DancerWhereUniqueInput;
  update: DancerUpdateWithoutParentDataInput;
  create: DancerCreateWithoutParentInput;
}

export interface DancerScalarWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  avatar?: Maybe<String>;
  avatar_not?: Maybe<String>;
  avatar_in?: Maybe<String[] | String>;
  avatar_not_in?: Maybe<String[] | String>;
  avatar_lt?: Maybe<String>;
  avatar_lte?: Maybe<String>;
  avatar_gt?: Maybe<String>;
  avatar_gte?: Maybe<String>;
  avatar_contains?: Maybe<String>;
  avatar_not_contains?: Maybe<String>;
  avatar_starts_with?: Maybe<String>;
  avatar_not_starts_with?: Maybe<String>;
  avatar_ends_with?: Maybe<String>;
  avatar_not_ends_with?: Maybe<String>;
  avatarId?: Maybe<String>;
  avatarId_not?: Maybe<String>;
  avatarId_in?: Maybe<String[] | String>;
  avatarId_not_in?: Maybe<String[] | String>;
  avatarId_lt?: Maybe<String>;
  avatarId_lte?: Maybe<String>;
  avatarId_gt?: Maybe<String>;
  avatarId_gte?: Maybe<String>;
  avatarId_contains?: Maybe<String>;
  avatarId_not_contains?: Maybe<String>;
  avatarId_starts_with?: Maybe<String>;
  avatarId_not_starts_with?: Maybe<String>;
  avatarId_ends_with?: Maybe<String>;
  avatarId_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  AND?: Maybe<DancerScalarWhereInput[] | DancerScalarWhereInput>;
  OR?: Maybe<DancerScalarWhereInput[] | DancerScalarWhereInput>;
  NOT?: Maybe<DancerScalarWhereInput[] | DancerScalarWhereInput>;
}

export interface DancerUpdateManyWithWhereNestedInput {
  where: DancerScalarWhereInput;
  data: DancerUpdateManyDataInput;
}

export interface DancerUpdateManyDataInput {
  firstName?: Maybe<String>;
  avatar?: Maybe<String>;
  avatarId?: Maybe<String>;
  lastName?: Maybe<String>;
}

export interface ParentUpsertNestedInput {
  update: ParentUpdateDataInput;
  create: ParentCreateInput;
}

export interface AccessRequestUpsertWithWhereUniqueWithoutStudioInput {
  where: AccessRequestWhereUniqueInput;
  update: AccessRequestUpdateWithoutStudioDataInput;
  create: AccessRequestCreateWithoutStudioInput;
}

export interface AccessRequestScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<AccessRequestScalarWhereInput[] | AccessRequestScalarWhereInput>;
  OR?: Maybe<AccessRequestScalarWhereInput[] | AccessRequestScalarWhereInput>;
  NOT?: Maybe<AccessRequestScalarWhereInput[] | AccessRequestScalarWhereInput>;
}

export interface StudioUpsertWithoutEnrollmentRequestsInput {
  update: StudioUpdateWithoutEnrollmentRequestsDataInput;
  create: StudioCreateWithoutEnrollmentRequestsInput;
}

export interface EnrollmentRequestUpsertWithoutDancerInput {
  update: EnrollmentRequestUpdateWithoutDancerDataInput;
  create: EnrollmentRequestCreateWithoutDancerInput;
}

export interface DancerUpsertWithWhereUniqueWithoutStudiosInput {
  where: DancerWhereUniqueInput;
  update: DancerUpdateWithoutStudiosDataInput;
  create: DancerCreateWithoutStudiosInput;
}

export interface StudioUpsertWithoutDanceClassesInput {
  update: StudioUpdateWithoutDanceClassesDataInput;
  create: StudioCreateWithoutDanceClassesInput;
}

export interface DanceClassUpsertWithWhereUniqueWithoutMakeupSetInput {
  where: DanceClassWhereUniqueInput;
  update: DanceClassUpdateWithoutMakeupSetDataInput;
  create: DanceClassCreateWithoutMakeupSetInput;
}

export interface MakeupSetUpsertWithWhereUniqueWithoutStudioInput {
  where: MakeupSetWhereUniqueInput;
  update: MakeupSetUpdateWithoutStudioDataInput;
  create: MakeupSetCreateWithoutStudioInput;
}

export interface MakeupSetScalarWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  lipstick?: Maybe<String>;
  lipstick_not?: Maybe<String>;
  lipstick_in?: Maybe<String[] | String>;
  lipstick_not_in?: Maybe<String[] | String>;
  lipstick_lt?: Maybe<String>;
  lipstick_lte?: Maybe<String>;
  lipstick_gt?: Maybe<String>;
  lipstick_gte?: Maybe<String>;
  lipstick_contains?: Maybe<String>;
  lipstick_not_contains?: Maybe<String>;
  lipstick_starts_with?: Maybe<String>;
  lipstick_not_starts_with?: Maybe<String>;
  lipstick_ends_with?: Maybe<String>;
  lipstick_not_ends_with?: Maybe<String>;
  eyeShadow?: Maybe<String>;
  eyeShadow_not?: Maybe<String>;
  eyeShadow_in?: Maybe<String[] | String>;
  eyeShadow_not_in?: Maybe<String[] | String>;
  eyeShadow_lt?: Maybe<String>;
  eyeShadow_lte?: Maybe<String>;
  eyeShadow_gt?: Maybe<String>;
  eyeShadow_gte?: Maybe<String>;
  eyeShadow_contains?: Maybe<String>;
  eyeShadow_not_contains?: Maybe<String>;
  eyeShadow_starts_with?: Maybe<String>;
  eyeShadow_not_starts_with?: Maybe<String>;
  eyeShadow_ends_with?: Maybe<String>;
  eyeShadow_not_ends_with?: Maybe<String>;
  eyeLids?: Maybe<String>;
  eyeLids_not?: Maybe<String>;
  eyeLids_in?: Maybe<String[] | String>;
  eyeLids_not_in?: Maybe<String[] | String>;
  eyeLids_lt?: Maybe<String>;
  eyeLids_lte?: Maybe<String>;
  eyeLids_gt?: Maybe<String>;
  eyeLids_gte?: Maybe<String>;
  eyeLids_contains?: Maybe<String>;
  eyeLids_not_contains?: Maybe<String>;
  eyeLids_starts_with?: Maybe<String>;
  eyeLids_not_starts_with?: Maybe<String>;
  eyeLids_ends_with?: Maybe<String>;
  eyeLids_not_ends_with?: Maybe<String>;
  eyeCrease?: Maybe<String>;
  eyeCrease_not?: Maybe<String>;
  eyeCrease_in?: Maybe<String[] | String>;
  eyeCrease_not_in?: Maybe<String[] | String>;
  eyeCrease_lt?: Maybe<String>;
  eyeCrease_lte?: Maybe<String>;
  eyeCrease_gt?: Maybe<String>;
  eyeCrease_gte?: Maybe<String>;
  eyeCrease_contains?: Maybe<String>;
  eyeCrease_not_contains?: Maybe<String>;
  eyeCrease_starts_with?: Maybe<String>;
  eyeCrease_not_starts_with?: Maybe<String>;
  eyeCrease_ends_with?: Maybe<String>;
  eyeCrease_not_ends_with?: Maybe<String>;
  eyeLiner?: Maybe<String>;
  eyeLiner_not?: Maybe<String>;
  eyeLiner_in?: Maybe<String[] | String>;
  eyeLiner_not_in?: Maybe<String[] | String>;
  eyeLiner_lt?: Maybe<String>;
  eyeLiner_lte?: Maybe<String>;
  eyeLiner_gt?: Maybe<String>;
  eyeLiner_gte?: Maybe<String>;
  eyeLiner_contains?: Maybe<String>;
  eyeLiner_not_contains?: Maybe<String>;
  eyeLiner_starts_with?: Maybe<String>;
  eyeLiner_not_starts_with?: Maybe<String>;
  eyeLiner_ends_with?: Maybe<String>;
  eyeLiner_not_ends_with?: Maybe<String>;
  eyelashes?: Maybe<String>;
  eyelashes_not?: Maybe<String>;
  eyelashes_in?: Maybe<String[] | String>;
  eyelashes_not_in?: Maybe<String[] | String>;
  eyelashes_lt?: Maybe<String>;
  eyelashes_lte?: Maybe<String>;
  eyelashes_gt?: Maybe<String>;
  eyelashes_gte?: Maybe<String>;
  eyelashes_contains?: Maybe<String>;
  eyelashes_not_contains?: Maybe<String>;
  eyelashes_starts_with?: Maybe<String>;
  eyelashes_not_starts_with?: Maybe<String>;
  eyelashes_ends_with?: Maybe<String>;
  eyelashes_not_ends_with?: Maybe<String>;
  foundation?: Maybe<String>;
  foundation_not?: Maybe<String>;
  foundation_in?: Maybe<String[] | String>;
  foundation_not_in?: Maybe<String[] | String>;
  foundation_lt?: Maybe<String>;
  foundation_lte?: Maybe<String>;
  foundation_gt?: Maybe<String>;
  foundation_gte?: Maybe<String>;
  foundation_contains?: Maybe<String>;
  foundation_not_contains?: Maybe<String>;
  foundation_starts_with?: Maybe<String>;
  foundation_not_starts_with?: Maybe<String>;
  foundation_ends_with?: Maybe<String>;
  foundation_not_ends_with?: Maybe<String>;
  powder?: Maybe<String>;
  powder_not?: Maybe<String>;
  powder_in?: Maybe<String[] | String>;
  powder_not_in?: Maybe<String[] | String>;
  powder_lt?: Maybe<String>;
  powder_lte?: Maybe<String>;
  powder_gt?: Maybe<String>;
  powder_gte?: Maybe<String>;
  powder_contains?: Maybe<String>;
  powder_not_contains?: Maybe<String>;
  powder_starts_with?: Maybe<String>;
  powder_not_starts_with?: Maybe<String>;
  powder_ends_with?: Maybe<String>;
  powder_not_ends_with?: Maybe<String>;
  blush?: Maybe<String>;
  blush_not?: Maybe<String>;
  blush_in?: Maybe<String[] | String>;
  blush_not_in?: Maybe<String[] | String>;
  blush_lt?: Maybe<String>;
  blush_lte?: Maybe<String>;
  blush_gt?: Maybe<String>;
  blush_gte?: Maybe<String>;
  blush_contains?: Maybe<String>;
  blush_not_contains?: Maybe<String>;
  blush_starts_with?: Maybe<String>;
  blush_not_starts_with?: Maybe<String>;
  blush_ends_with?: Maybe<String>;
  blush_not_ends_with?: Maybe<String>;
  bronzer?: Maybe<String>;
  bronzer_not?: Maybe<String>;
  bronzer_in?: Maybe<String[] | String>;
  bronzer_not_in?: Maybe<String[] | String>;
  bronzer_lt?: Maybe<String>;
  bronzer_lte?: Maybe<String>;
  bronzer_gt?: Maybe<String>;
  bronzer_gte?: Maybe<String>;
  bronzer_contains?: Maybe<String>;
  bronzer_not_contains?: Maybe<String>;
  bronzer_starts_with?: Maybe<String>;
  bronzer_not_starts_with?: Maybe<String>;
  bronzer_ends_with?: Maybe<String>;
  bronzer_not_ends_with?: Maybe<String>;
  applyToCategories?: Maybe<String>;
  applyToCategories_not?: Maybe<String>;
  applyToCategories_in?: Maybe<String[] | String>;
  applyToCategories_not_in?: Maybe<String[] | String>;
  applyToCategories_lt?: Maybe<String>;
  applyToCategories_lte?: Maybe<String>;
  applyToCategories_gt?: Maybe<String>;
  applyToCategories_gte?: Maybe<String>;
  applyToCategories_contains?: Maybe<String>;
  applyToCategories_not_contains?: Maybe<String>;
  applyToCategories_starts_with?: Maybe<String>;
  applyToCategories_not_starts_with?: Maybe<String>;
  applyToCategories_ends_with?: Maybe<String>;
  applyToCategories_not_ends_with?: Maybe<String>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  AND?: Maybe<MakeupSetScalarWhereInput[] | MakeupSetScalarWhereInput>;
  OR?: Maybe<MakeupSetScalarWhereInput[] | MakeupSetScalarWhereInput>;
  NOT?: Maybe<MakeupSetScalarWhereInput[] | MakeupSetScalarWhereInput>;
}

export interface MakeupSetUpdateManyWithWhereNestedInput {
  where: MakeupSetScalarWhereInput;
  data: MakeupSetUpdateManyDataInput;
}

export interface MakeupSetUpdateManyDataInput {
  name?: Maybe<String>;
  lipstick?: Maybe<String>;
  eyeShadow?: Maybe<String>;
  eyeLids?: Maybe<String>;
  eyeCrease?: Maybe<String>;
  eyeLiner?: Maybe<String>;
  eyelashes?: Maybe<String>;
  foundation?: Maybe<String>;
  powder?: Maybe<String>;
  blush?: Maybe<String>;
  bronzer?: Maybe<String>;
  applyToCategories?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface StudioUpsertNestedInput {
  update: StudioUpdateDataInput;
  create: StudioCreateInput;
}

export interface DancerUpdateManyWithoutCustomRoutinesInput {
  create?: Maybe<
    | DancerCreateWithoutCustomRoutinesInput[]
    | DancerCreateWithoutCustomRoutinesInput
  >;
  delete?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
  connect?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
  set?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
  disconnect?: Maybe<DancerWhereUniqueInput[] | DancerWhereUniqueInput>;
  update?: Maybe<
    | DancerUpdateWithWhereUniqueWithoutCustomRoutinesInput[]
    | DancerUpdateWithWhereUniqueWithoutCustomRoutinesInput
  >;
  upsert?: Maybe<
    | DancerUpsertWithWhereUniqueWithoutCustomRoutinesInput[]
    | DancerUpsertWithWhereUniqueWithoutCustomRoutinesInput
  >;
  deleteMany?: Maybe<DancerScalarWhereInput[] | DancerScalarWhereInput>;
  updateMany?: Maybe<
    | DancerUpdateManyWithWhereNestedInput[]
    | DancerUpdateManyWithWhereNestedInput
  >;
}

export interface DancerUpdateWithWhereUniqueWithoutCustomRoutinesInput {
  where: DancerWhereUniqueInput;
  data: DancerUpdateWithoutCustomRoutinesDataInput;
}

export interface DancerUpdateWithoutCustomRoutinesDataInput {
  firstName?: Maybe<String>;
  parent?: Maybe<ParentUpdateOneRequiredWithoutDancersInput>;
  requests?: Maybe<EnrollmentRequestUpdateOneWithoutDancerInput>;
  danceClasses?: Maybe<DanceClassUpdateManyWithoutDancersInput>;
  avatar?: Maybe<String>;
  avatarId?: Maybe<String>;
  lastName?: Maybe<String>;
  studios?: Maybe<StudioUpdateManyWithoutDancersInput>;
}

export interface DancerUpsertWithWhereUniqueWithoutCustomRoutinesInput {
  where: DancerWhereUniqueInput;
  update: DancerUpdateWithoutCustomRoutinesDataInput;
  create: DancerCreateWithoutCustomRoutinesInput;
}

export interface CustomRoutineUpsertWithWhereUniqueWithoutParentInput {
  where: CustomRoutineWhereUniqueInput;
  update: CustomRoutineUpdateWithoutParentDataInput;
  create: CustomRoutineCreateWithoutParentInput;
}

export interface ParentUpsertWithoutDancersInput {
  update: ParentUpdateWithoutDancersDataInput;
  create: ParentCreateWithoutDancersInput;
}

export interface DancerUpsertWithWhereUniqueWithoutDanceClassesInput {
  where: DancerWhereUniqueInput;
  update: DancerUpdateWithoutDanceClassesDataInput;
  create: DancerCreateWithoutDanceClassesInput;
}

export interface DanceClassUpsertWithWhereUniqueWithoutStudioInput {
  where: DanceClassWhereUniqueInput;
  update: DanceClassUpdateWithoutStudioDataInput;
  create: DanceClassCreateWithoutStudioInput;
}

export interface StudioUpsertWithoutAccessRequestsInput {
  update: StudioUpdateWithoutAccessRequestsDataInput;
  create: StudioCreateWithoutAccessRequestsInput;
}

export interface CustomRoutineCreateInput {
  custom: Boolean;
  id?: Maybe<ID_Input>;
  name: String;
  studio?: Maybe<StudioCreateOneInput>;
  parent: ParentCreateOneWithoutCustomRoutinesInput;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  style?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  shoes?: Maybe<String>;
  tights?: Maybe<String>;
  notes?: Maybe<String>;
  dancers?: Maybe<DancerCreateManyWithoutCustomRoutinesInput>;
  type?: Maybe<String>;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
}

export interface CustomRoutineUpdateInput {
  custom?: Maybe<Boolean>;
  name?: Maybe<String>;
  studio?: Maybe<StudioUpdateOneInput>;
  parent?: Maybe<ParentUpdateOneRequiredWithoutCustomRoutinesInput>;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  style?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  shoes?: Maybe<String>;
  tights?: Maybe<String>;
  notes?: Maybe<String>;
  dancers?: Maybe<DancerUpdateManyWithoutCustomRoutinesInput>;
  type?: Maybe<String>;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
}

export interface CustomRoutineUpdateManyMutationInput {
  custom?: Maybe<Boolean>;
  name?: Maybe<String>;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  style?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  shoes?: Maybe<String>;
  tights?: Maybe<String>;
  notes?: Maybe<String>;
  type?: Maybe<String>;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
}

export interface DanceClassUpdateInput {
  name?: Maybe<String>;
  studio?: Maybe<StudioUpdateOneRequiredWithoutDanceClassesInput>;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  style?: Maybe<String>;
  tights?: Maybe<String>;
  shoes?: Maybe<String>;
  notes?: Maybe<String>;
  dancers?: Maybe<DancerUpdateManyWithoutDanceClassesInput>;
  makeupSet?: Maybe<MakeupSetUpdateOneWithoutDanceClassesInput>;
  size?: Maybe<String>;
  custom?: Maybe<Boolean>;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
  videoUrl?: Maybe<String>;
  videoId?: Maybe<String>;
}

export interface DanceClassUpdateManyMutationInput {
  name?: Maybe<String>;
  music?: Maybe<String>;
  musicId?: Maybe<String>;
  performanceName?: Maybe<String>;
  day?: Maybe<String>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  competitiveLevel?: Maybe<String>;
  ageDivision?: Maybe<String>;
  style?: Maybe<String>;
  tights?: Maybe<String>;
  shoes?: Maybe<String>;
  notes?: Maybe<String>;
  size?: Maybe<String>;
  custom?: Maybe<Boolean>;
  entryNumber?: Maybe<String>;
  entryTime?: Maybe<String>;
  entryDay?: Maybe<String>;
  videoUrl?: Maybe<String>;
  videoId?: Maybe<String>;
}

export interface DancerCreateInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  parent: ParentCreateOneWithoutDancersInput;
  requests?: Maybe<EnrollmentRequestCreateOneWithoutDancerInput>;
  danceClasses?: Maybe<DanceClassCreateManyWithoutDancersInput>;
  customRoutines?: Maybe<CustomRoutineCreateManyWithoutDancersInput>;
  avatar?: Maybe<String>;
  avatarId?: Maybe<String>;
  lastName?: Maybe<String>;
  studios?: Maybe<StudioCreateManyWithoutDancersInput>;
}

export interface DancerUpdateInput {
  firstName?: Maybe<String>;
  parent?: Maybe<ParentUpdateOneRequiredWithoutDancersInput>;
  requests?: Maybe<EnrollmentRequestUpdateOneWithoutDancerInput>;
  danceClasses?: Maybe<DanceClassUpdateManyWithoutDancersInput>;
  customRoutines?: Maybe<CustomRoutineUpdateManyWithoutDancersInput>;
  avatar?: Maybe<String>;
  avatarId?: Maybe<String>;
  lastName?: Maybe<String>;
  studios?: Maybe<StudioUpdateManyWithoutDancersInput>;
}

export interface DancerUpdateManyMutationInput {
  firstName?: Maybe<String>;
  avatar?: Maybe<String>;
  avatarId?: Maybe<String>;
  lastName?: Maybe<String>;
}

export interface EnrollmentRequestCreateInput {
  id?: Maybe<ID_Input>;
  studio: StudioCreateOneWithoutEnrollmentRequestsInput;
  parent: ParentCreateOneInput;
  dancer: DancerCreateOneWithoutRequestsInput;
  classesRequested?: Maybe<DanceClassCreateManyInput>;
}

export interface EnrollmentRequestUpdateInput {
  studio?: Maybe<StudioUpdateOneRequiredWithoutEnrollmentRequestsInput>;
  parent?: Maybe<ParentUpdateOneRequiredInput>;
  dancer?: Maybe<DancerUpdateOneRequiredWithoutRequestsInput>;
  classesRequested?: Maybe<DanceClassUpdateManyInput>;
}

export interface HairStyleCreateInput {
  studio: StudioCreateOneWithoutHairStylesInput;
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
}

export interface StudioCreateOneWithoutHairStylesInput {
  create?: Maybe<StudioCreateWithoutHairStylesInput>;
  connect?: Maybe<StudioWhereUniqueInput>;
}

export interface StudioCreateWithoutHairStylesInput {
  id?: Maybe<ID_Input>;
  email: String;
  studioName: String;
  userType: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  danceClasses?: Maybe<DanceClassCreateManyWithoutStudioInput>;
  styles?: Maybe<StudioCreatestylesInput>;
  competitiveLevels?: Maybe<StudioCreatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioCreateageDivisionsInput>;
  makeupSets?: Maybe<MakeupSetCreateManyWithoutStudioInput>;
  dancers?: Maybe<DancerCreateManyWithoutStudiosInput>;
  events?: Maybe<StudioEventCreateManyWithoutStudioInput>;
  website?: Maybe<String>;
  enrollmentRequests?: Maybe<EnrollmentRequestCreateManyWithoutStudioInput>;
  accessRequests?: Maybe<AccessRequestCreateManyWithoutStudioInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface HairStyleUpdateInput {
  studio?: Maybe<StudioUpdateOneRequiredWithoutHairStylesInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
}

export interface StudioUpdateOneRequiredWithoutHairStylesInput {
  create?: Maybe<StudioCreateWithoutHairStylesInput>;
  update?: Maybe<StudioUpdateWithoutHairStylesDataInput>;
  upsert?: Maybe<StudioUpsertWithoutHairStylesInput>;
  connect?: Maybe<StudioWhereUniqueInput>;
}

export interface StudioUpdateWithoutHairStylesDataInput {
  email?: Maybe<String>;
  studioName?: Maybe<String>;
  userType?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  danceClasses?: Maybe<DanceClassUpdateManyWithoutStudioInput>;
  styles?: Maybe<StudioUpdatestylesInput>;
  competitiveLevels?: Maybe<StudioUpdatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioUpdateageDivisionsInput>;
  makeupSets?: Maybe<MakeupSetUpdateManyWithoutStudioInput>;
  dancers?: Maybe<DancerUpdateManyWithoutStudiosInput>;
  events?: Maybe<StudioEventUpdateManyWithoutStudioInput>;
  website?: Maybe<String>;
  enrollmentRequests?: Maybe<EnrollmentRequestUpdateManyWithoutStudioInput>;
  accessRequests?: Maybe<AccessRequestUpdateManyWithoutStudioInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface StudioUpsertWithoutHairStylesInput {
  update: StudioUpdateWithoutHairStylesDataInput;
  create: StudioCreateWithoutHairStylesInput;
}

export interface HairStyleUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
}

export interface MakeupSetCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  studio: StudioCreateOneWithoutMakeupSetsInput;
  lipstick?: Maybe<String>;
  eyeShadow?: Maybe<String>;
  eyeLids?: Maybe<String>;
  eyeCrease?: Maybe<String>;
  eyeLiner?: Maybe<String>;
  eyelashes?: Maybe<String>;
  foundation?: Maybe<String>;
  powder?: Maybe<String>;
  blush?: Maybe<String>;
  bronzer?: Maybe<String>;
  applyToCategories?: Maybe<String>;
  notes?: Maybe<String>;
  danceClasses?: Maybe<DanceClassCreateManyWithoutMakeupSetInput>;
}

export interface MakeupSetUpdateInput {
  name?: Maybe<String>;
  studio?: Maybe<StudioUpdateOneRequiredWithoutMakeupSetsInput>;
  lipstick?: Maybe<String>;
  eyeShadow?: Maybe<String>;
  eyeLids?: Maybe<String>;
  eyeCrease?: Maybe<String>;
  eyeLiner?: Maybe<String>;
  eyelashes?: Maybe<String>;
  foundation?: Maybe<String>;
  powder?: Maybe<String>;
  blush?: Maybe<String>;
  bronzer?: Maybe<String>;
  applyToCategories?: Maybe<String>;
  notes?: Maybe<String>;
  danceClasses?: Maybe<DanceClassUpdateManyWithoutMakeupSetInput>;
}

export interface MakeupSetUpdateManyMutationInput {
  name?: Maybe<String>;
  lipstick?: Maybe<String>;
  eyeShadow?: Maybe<String>;
  eyeLids?: Maybe<String>;
  eyeCrease?: Maybe<String>;
  eyeLiner?: Maybe<String>;
  eyelashes?: Maybe<String>;
  foundation?: Maybe<String>;
  powder?: Maybe<String>;
  blush?: Maybe<String>;
  bronzer?: Maybe<String>;
  applyToCategories?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface ParentUpdateInput {
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  userType?: Maybe<String>;
  dancers?: Maybe<DancerUpdateManyWithoutParentInput>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  customRoutines?: Maybe<CustomRoutineUpdateManyWithoutParentInput>;
  studios?: Maybe<StudioUpdateManyInput>;
  accessRequests?: Maybe<ParentUpdateaccessRequestsInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface ParentUpdateManyMutationInput {
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  userType?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  accessRequests?: Maybe<ParentUpdateaccessRequestsInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface ParentEventCreateInput {
  id?: Maybe<ID_Input>;
  parent: ParentCreateOneInput;
  studio?: Maybe<StudioCreateOneInput>;
  name: String;
  type: String;
  dancerIds?: Maybe<ParentEventCreatedancerIdsInput>;
  appliesTo?: Maybe<ParentEventCreateappliesToInput>;
  beginDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  location?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<String>;
  url?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface ParentEventCreatedancerIdsInput {
  set?: Maybe<ID_Input[] | ID_Input>;
}

export interface ParentEventCreateappliesToInput {
  set?: Maybe<String[] | String>;
}

export interface ParentEventUpdateInput {
  parent?: Maybe<ParentUpdateOneRequiredInput>;
  studio?: Maybe<StudioUpdateOneInput>;
  name?: Maybe<String>;
  type?: Maybe<String>;
  dancerIds?: Maybe<ParentEventUpdatedancerIdsInput>;
  appliesTo?: Maybe<ParentEventUpdateappliesToInput>;
  beginDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  location?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<String>;
  url?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface ParentEventUpdatedancerIdsInput {
  set?: Maybe<ID_Input[] | ID_Input>;
}

export interface ParentEventUpdateappliesToInput {
  set?: Maybe<String[] | String>;
}

export interface ParentEventUpdateManyMutationInput {
  name?: Maybe<String>;
  type?: Maybe<String>;
  dancerIds?: Maybe<ParentEventUpdatedancerIdsInput>;
  appliesTo?: Maybe<ParentEventUpdateappliesToInput>;
  beginDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  location?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<String>;
  url?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface ParentNoteCreateInput {
  id?: Maybe<ID_Input>;
  parent: ParentCreateOneInput;
  dance: DanceClassCreateOneInput;
  note: String;
}

export interface DanceClassCreateOneInput {
  create?: Maybe<DanceClassCreateInput>;
  connect?: Maybe<DanceClassWhereUniqueInput>;
}

export interface ParentNoteUpdateInput {
  parent?: Maybe<ParentUpdateOneRequiredInput>;
  dance?: Maybe<DanceClassUpdateOneRequiredInput>;
  note?: Maybe<String>;
}

export interface DanceClassUpdateOneRequiredInput {
  create?: Maybe<DanceClassCreateInput>;
  update?: Maybe<DanceClassUpdateDataInput>;
  upsert?: Maybe<DanceClassUpsertNestedInput>;
  connect?: Maybe<DanceClassWhereUniqueInput>;
}

export interface DanceClassUpsertNestedInput {
  update: DanceClassUpdateDataInput;
  create: DanceClassCreateInput;
}

export interface ParentNoteUpdateManyMutationInput {
  note?: Maybe<String>;
}

export interface StudioUpdateInput {
  email?: Maybe<String>;
  studioName?: Maybe<String>;
  userType?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  danceClasses?: Maybe<DanceClassUpdateManyWithoutStudioInput>;
  styles?: Maybe<StudioUpdatestylesInput>;
  competitiveLevels?: Maybe<StudioUpdatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioUpdateageDivisionsInput>;
  makeupSets?: Maybe<MakeupSetUpdateManyWithoutStudioInput>;
  hairStyles?: Maybe<HairStyleUpdateManyWithoutStudioInput>;
  dancers?: Maybe<DancerUpdateManyWithoutStudiosInput>;
  events?: Maybe<StudioEventUpdateManyWithoutStudioInput>;
  website?: Maybe<String>;
  enrollmentRequests?: Maybe<EnrollmentRequestUpdateManyWithoutStudioInput>;
  accessRequests?: Maybe<AccessRequestUpdateManyWithoutStudioInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface StudioUpdateManyMutationInput {
  email?: Maybe<String>;
  studioName?: Maybe<String>;
  userType?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  styles?: Maybe<StudioUpdatestylesInput>;
  competitiveLevels?: Maybe<StudioUpdatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioUpdateageDivisionsInput>;
  website?: Maybe<String>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface StudioEventCreateInput {
  id?: Maybe<ID_Input>;
  studio: StudioCreateOneWithoutEventsInput;
  name: String;
  type: String;
  appliesTo?: Maybe<StudioEventCreateappliesToInput>;
  beginDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  location?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<String>;
  url?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface StudioCreateOneWithoutEventsInput {
  create?: Maybe<StudioCreateWithoutEventsInput>;
  connect?: Maybe<StudioWhereUniqueInput>;
}

export interface StudioCreateWithoutEventsInput {
  id?: Maybe<ID_Input>;
  email: String;
  studioName: String;
  userType: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  danceClasses?: Maybe<DanceClassCreateManyWithoutStudioInput>;
  styles?: Maybe<StudioCreatestylesInput>;
  competitiveLevels?: Maybe<StudioCreatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioCreateageDivisionsInput>;
  makeupSets?: Maybe<MakeupSetCreateManyWithoutStudioInput>;
  hairStyles?: Maybe<HairStyleCreateManyWithoutStudioInput>;
  dancers?: Maybe<DancerCreateManyWithoutStudiosInput>;
  website?: Maybe<String>;
  enrollmentRequests?: Maybe<EnrollmentRequestCreateManyWithoutStudioInput>;
  accessRequests?: Maybe<AccessRequestCreateManyWithoutStudioInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface StudioEventUpdateInput {
  studio?: Maybe<StudioUpdateOneRequiredWithoutEventsInput>;
  name?: Maybe<String>;
  type?: Maybe<String>;
  appliesTo?: Maybe<StudioEventUpdateappliesToInput>;
  beginDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  location?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<String>;
  url?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface StudioUpdateOneRequiredWithoutEventsInput {
  create?: Maybe<StudioCreateWithoutEventsInput>;
  update?: Maybe<StudioUpdateWithoutEventsDataInput>;
  upsert?: Maybe<StudioUpsertWithoutEventsInput>;
  connect?: Maybe<StudioWhereUniqueInput>;
}

export interface StudioUpdateWithoutEventsDataInput {
  email?: Maybe<String>;
  studioName?: Maybe<String>;
  userType?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  danceClasses?: Maybe<DanceClassUpdateManyWithoutStudioInput>;
  styles?: Maybe<StudioUpdatestylesInput>;
  competitiveLevels?: Maybe<StudioUpdatecompetitiveLevelsInput>;
  ageDivisions?: Maybe<StudioUpdateageDivisionsInput>;
  makeupSets?: Maybe<MakeupSetUpdateManyWithoutStudioInput>;
  hairStyles?: Maybe<HairStyleUpdateManyWithoutStudioInput>;
  dancers?: Maybe<DancerUpdateManyWithoutStudiosInput>;
  website?: Maybe<String>;
  enrollmentRequests?: Maybe<EnrollmentRequestUpdateManyWithoutStudioInput>;
  accessRequests?: Maybe<AccessRequestUpdateManyWithoutStudioInput>;
  agreeToTerms?: Maybe<DateTimeInput>;
  readPrivacy?: Maybe<DateTimeInput>;
}

export interface StudioUpsertWithoutEventsInput {
  update: StudioUpdateWithoutEventsDataInput;
  create: StudioCreateWithoutEventsInput;
}

export interface StudioEventUpdateManyMutationInput {
  name?: Maybe<String>;
  type?: Maybe<String>;
  appliesTo?: Maybe<StudioEventUpdateappliesToInput>;
  beginDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  location?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<String>;
  url?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface AccessRequestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AccessRequestWhereInput>;
  AND?: Maybe<
    AccessRequestSubscriptionWhereInput[] | AccessRequestSubscriptionWhereInput
  >;
  OR?: Maybe<
    AccessRequestSubscriptionWhereInput[] | AccessRequestSubscriptionWhereInput
  >;
  NOT?: Maybe<
    AccessRequestSubscriptionWhereInput[] | AccessRequestSubscriptionWhereInput
  >;
}

export interface CustomRoutineSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomRoutineWhereInput>;
  AND?: Maybe<
    CustomRoutineSubscriptionWhereInput[] | CustomRoutineSubscriptionWhereInput
  >;
  OR?: Maybe<
    CustomRoutineSubscriptionWhereInput[] | CustomRoutineSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CustomRoutineSubscriptionWhereInput[] | CustomRoutineSubscriptionWhereInput
  >;
}

export interface DanceClassSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DanceClassWhereInput>;
  AND?: Maybe<
    DanceClassSubscriptionWhereInput[] | DanceClassSubscriptionWhereInput
  >;
  OR?: Maybe<
    DanceClassSubscriptionWhereInput[] | DanceClassSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DanceClassSubscriptionWhereInput[] | DanceClassSubscriptionWhereInput
  >;
}

export interface DancerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DancerWhereInput>;
  AND?: Maybe<DancerSubscriptionWhereInput[] | DancerSubscriptionWhereInput>;
  OR?: Maybe<DancerSubscriptionWhereInput[] | DancerSubscriptionWhereInput>;
  NOT?: Maybe<DancerSubscriptionWhereInput[] | DancerSubscriptionWhereInput>;
}

export interface EnrollmentRequestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EnrollmentRequestWhereInput>;
  AND?: Maybe<
    | EnrollmentRequestSubscriptionWhereInput[]
    | EnrollmentRequestSubscriptionWhereInput
  >;
  OR?: Maybe<
    | EnrollmentRequestSubscriptionWhereInput[]
    | EnrollmentRequestSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | EnrollmentRequestSubscriptionWhereInput[]
    | EnrollmentRequestSubscriptionWhereInput
  >;
}

export interface HairStyleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HairStyleWhereInput>;
  AND?: Maybe<
    HairStyleSubscriptionWhereInput[] | HairStyleSubscriptionWhereInput
  >;
  OR?: Maybe<
    HairStyleSubscriptionWhereInput[] | HairStyleSubscriptionWhereInput
  >;
  NOT?: Maybe<
    HairStyleSubscriptionWhereInput[] | HairStyleSubscriptionWhereInput
  >;
}

export interface MakeupSetSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MakeupSetWhereInput>;
  AND?: Maybe<
    MakeupSetSubscriptionWhereInput[] | MakeupSetSubscriptionWhereInput
  >;
  OR?: Maybe<
    MakeupSetSubscriptionWhereInput[] | MakeupSetSubscriptionWhereInput
  >;
  NOT?: Maybe<
    MakeupSetSubscriptionWhereInput[] | MakeupSetSubscriptionWhereInput
  >;
}

export interface ParentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ParentWhereInput>;
  AND?: Maybe<ParentSubscriptionWhereInput[] | ParentSubscriptionWhereInput>;
  OR?: Maybe<ParentSubscriptionWhereInput[] | ParentSubscriptionWhereInput>;
  NOT?: Maybe<ParentSubscriptionWhereInput[] | ParentSubscriptionWhereInput>;
}

export interface ParentEventSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ParentEventWhereInput>;
  AND?: Maybe<
    ParentEventSubscriptionWhereInput[] | ParentEventSubscriptionWhereInput
  >;
  OR?: Maybe<
    ParentEventSubscriptionWhereInput[] | ParentEventSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ParentEventSubscriptionWhereInput[] | ParentEventSubscriptionWhereInput
  >;
}

export interface ParentNoteSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ParentNoteWhereInput>;
  AND?: Maybe<
    ParentNoteSubscriptionWhereInput[] | ParentNoteSubscriptionWhereInput
  >;
  OR?: Maybe<
    ParentNoteSubscriptionWhereInput[] | ParentNoteSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ParentNoteSubscriptionWhereInput[] | ParentNoteSubscriptionWhereInput
  >;
}

export interface StudioSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StudioWhereInput>;
  AND?: Maybe<StudioSubscriptionWhereInput[] | StudioSubscriptionWhereInput>;
  OR?: Maybe<StudioSubscriptionWhereInput[] | StudioSubscriptionWhereInput>;
  NOT?: Maybe<StudioSubscriptionWhereInput[] | StudioSubscriptionWhereInput>;
}

export interface StudioEventSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StudioEventWhereInput>;
  AND?: Maybe<
    StudioEventSubscriptionWhereInput[] | StudioEventSubscriptionWhereInput
  >;
  OR?: Maybe<
    StudioEventSubscriptionWhereInput[] | StudioEventSubscriptionWhereInput
  >;
  NOT?: Maybe<
    StudioEventSubscriptionWhereInput[] | StudioEventSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface AccessRequest {
  id: ID_Output;
}

export interface AccessRequestPromise
  extends Promise<AccessRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  studio: <T = StudioPromise>() => T;
  parent: <T = ParentPromise>() => T;
}

export interface AccessRequestSubscription
  extends Promise<AsyncIterator<AccessRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  studio: <T = StudioSubscription>() => T;
  parent: <T = ParentSubscription>() => T;
}

export interface AccessRequestNullablePromise
  extends Promise<AccessRequest | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  studio: <T = StudioPromise>() => T;
  parent: <T = ParentPromise>() => T;
}

export interface Studio {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  id: ID_Output;
  email: String;
  studioName: String;
  userType: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  styles: String[];
  competitiveLevels: String[];
  ageDivisions: String[];
  website?: String;
  agreeToTerms?: DateTimeOutput;
  readPrivacy?: DateTimeOutput;
}

export interface StudioPromise extends Promise<Studio>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  studioName: () => Promise<String>;
  userType: () => Promise<String>;
  password: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  danceClasses: <T = FragmentableArray<DanceClass>>(args?: {
    where?: DanceClassWhereInput;
    orderBy?: DanceClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  styles: () => Promise<String[]>;
  competitiveLevels: () => Promise<String[]>;
  ageDivisions: () => Promise<String[]>;
  makeupSets: <T = FragmentableArray<MakeupSet>>(args?: {
    where?: MakeupSetWhereInput;
    orderBy?: MakeupSetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hairStyles: <T = FragmentableArray<HairStyle>>(args?: {
    where?: HairStyleWhereInput;
    orderBy?: HairStyleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dancers: <T = FragmentableArray<Dancer>>(args?: {
    where?: DancerWhereInput;
    orderBy?: DancerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  events: <T = FragmentableArray<StudioEvent>>(args?: {
    where?: StudioEventWhereInput;
    orderBy?: StudioEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  website: () => Promise<String>;
  enrollmentRequests: <T = FragmentableArray<EnrollmentRequest>>(args?: {
    where?: EnrollmentRequestWhereInput;
    orderBy?: EnrollmentRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  accessRequests: <T = FragmentableArray<AccessRequest>>(args?: {
    where?: AccessRequestWhereInput;
    orderBy?: AccessRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  agreeToTerms: () => Promise<DateTimeOutput>;
  readPrivacy: () => Promise<DateTimeOutput>;
}

export interface StudioSubscription
  extends Promise<AsyncIterator<Studio>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  studioName: () => Promise<AsyncIterator<String>>;
  userType: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  danceClasses: <T = Promise<AsyncIterator<DanceClassSubscription>>>(args?: {
    where?: DanceClassWhereInput;
    orderBy?: DanceClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  styles: () => Promise<AsyncIterator<String[]>>;
  competitiveLevels: () => Promise<AsyncIterator<String[]>>;
  ageDivisions: () => Promise<AsyncIterator<String[]>>;
  makeupSets: <T = Promise<AsyncIterator<MakeupSetSubscription>>>(args?: {
    where?: MakeupSetWhereInput;
    orderBy?: MakeupSetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hairStyles: <T = Promise<AsyncIterator<HairStyleSubscription>>>(args?: {
    where?: HairStyleWhereInput;
    orderBy?: HairStyleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dancers: <T = Promise<AsyncIterator<DancerSubscription>>>(args?: {
    where?: DancerWhereInput;
    orderBy?: DancerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  events: <T = Promise<AsyncIterator<StudioEventSubscription>>>(args?: {
    where?: StudioEventWhereInput;
    orderBy?: StudioEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  website: () => Promise<AsyncIterator<String>>;
  enrollmentRequests: <
    T = Promise<AsyncIterator<EnrollmentRequestSubscription>>
  >(args?: {
    where?: EnrollmentRequestWhereInput;
    orderBy?: EnrollmentRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  accessRequests: <
    T = Promise<AsyncIterator<AccessRequestSubscription>>
  >(args?: {
    where?: AccessRequestWhereInput;
    orderBy?: AccessRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  agreeToTerms: () => Promise<AsyncIterator<DateTimeOutput>>;
  readPrivacy: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StudioNullablePromise
  extends Promise<Studio | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  studioName: () => Promise<String>;
  userType: () => Promise<String>;
  password: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  danceClasses: <T = FragmentableArray<DanceClass>>(args?: {
    where?: DanceClassWhereInput;
    orderBy?: DanceClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  styles: () => Promise<String[]>;
  competitiveLevels: () => Promise<String[]>;
  ageDivisions: () => Promise<String[]>;
  makeupSets: <T = FragmentableArray<MakeupSet>>(args?: {
    where?: MakeupSetWhereInput;
    orderBy?: MakeupSetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hairStyles: <T = FragmentableArray<HairStyle>>(args?: {
    where?: HairStyleWhereInput;
    orderBy?: HairStyleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dancers: <T = FragmentableArray<Dancer>>(args?: {
    where?: DancerWhereInput;
    orderBy?: DancerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  events: <T = FragmentableArray<StudioEvent>>(args?: {
    where?: StudioEventWhereInput;
    orderBy?: StudioEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  website: () => Promise<String>;
  enrollmentRequests: <T = FragmentableArray<EnrollmentRequest>>(args?: {
    where?: EnrollmentRequestWhereInput;
    orderBy?: EnrollmentRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  accessRequests: <T = FragmentableArray<AccessRequest>>(args?: {
    where?: AccessRequestWhereInput;
    orderBy?: AccessRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  agreeToTerms: () => Promise<DateTimeOutput>;
  readPrivacy: () => Promise<DateTimeOutput>;
}

export interface DanceClass {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  id: ID_Output;
  name: String;
  music?: String;
  musicId?: String;
  performanceName?: String;
  day?: String;
  startTime?: String;
  endTime?: String;
  competitiveLevel?: String;
  ageDivision?: String;
  style?: String;
  tights?: String;
  shoes?: String;
  notes?: String;
  size: String;
  custom: Boolean;
  entryNumber?: String;
  entryTime?: String;
  entryDay?: String;
  videoUrl?: String;
  videoId?: String;
}

export interface DanceClassPromise extends Promise<DanceClass>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  studio: <T = StudioPromise>() => T;
  music: () => Promise<String>;
  musicId: () => Promise<String>;
  performanceName: () => Promise<String>;
  day: () => Promise<String>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
  competitiveLevel: () => Promise<String>;
  ageDivision: () => Promise<String>;
  style: () => Promise<String>;
  tights: () => Promise<String>;
  shoes: () => Promise<String>;
  notes: () => Promise<String>;
  dancers: <T = FragmentableArray<Dancer>>(args?: {
    where?: DancerWhereInput;
    orderBy?: DancerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  makeupSet: <T = MakeupSetPromise>() => T;
  size: () => Promise<String>;
  custom: () => Promise<Boolean>;
  entryNumber: () => Promise<String>;
  entryTime: () => Promise<String>;
  entryDay: () => Promise<String>;
  videoUrl: () => Promise<String>;
  videoId: () => Promise<String>;
}

export interface DanceClassSubscription
  extends Promise<AsyncIterator<DanceClass>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  studio: <T = StudioSubscription>() => T;
  music: () => Promise<AsyncIterator<String>>;
  musicId: () => Promise<AsyncIterator<String>>;
  performanceName: () => Promise<AsyncIterator<String>>;
  day: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<String>>;
  endTime: () => Promise<AsyncIterator<String>>;
  competitiveLevel: () => Promise<AsyncIterator<String>>;
  ageDivision: () => Promise<AsyncIterator<String>>;
  style: () => Promise<AsyncIterator<String>>;
  tights: () => Promise<AsyncIterator<String>>;
  shoes: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
  dancers: <T = Promise<AsyncIterator<DancerSubscription>>>(args?: {
    where?: DancerWhereInput;
    orderBy?: DancerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  makeupSet: <T = MakeupSetSubscription>() => T;
  size: () => Promise<AsyncIterator<String>>;
  custom: () => Promise<AsyncIterator<Boolean>>;
  entryNumber: () => Promise<AsyncIterator<String>>;
  entryTime: () => Promise<AsyncIterator<String>>;
  entryDay: () => Promise<AsyncIterator<String>>;
  videoUrl: () => Promise<AsyncIterator<String>>;
  videoId: () => Promise<AsyncIterator<String>>;
}

export interface DanceClassNullablePromise
  extends Promise<DanceClass | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  studio: <T = StudioPromise>() => T;
  music: () => Promise<String>;
  musicId: () => Promise<String>;
  performanceName: () => Promise<String>;
  day: () => Promise<String>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
  competitiveLevel: () => Promise<String>;
  ageDivision: () => Promise<String>;
  style: () => Promise<String>;
  tights: () => Promise<String>;
  shoes: () => Promise<String>;
  notes: () => Promise<String>;
  dancers: <T = FragmentableArray<Dancer>>(args?: {
    where?: DancerWhereInput;
    orderBy?: DancerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  makeupSet: <T = MakeupSetPromise>() => T;
  size: () => Promise<String>;
  custom: () => Promise<Boolean>;
  entryNumber: () => Promise<String>;
  entryTime: () => Promise<String>;
  entryDay: () => Promise<String>;
  videoUrl: () => Promise<String>;
  videoId: () => Promise<String>;
}

export interface Dancer {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  id: ID_Output;
  firstName: String;
  avatar?: String;
  avatarId?: String;
  lastName?: String;
}

export interface DancerPromise extends Promise<Dancer>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  parent: <T = ParentPromise>() => T;
  requests: <T = EnrollmentRequestPromise>() => T;
  danceClasses: <T = FragmentableArray<DanceClass>>(args?: {
    where?: DanceClassWhereInput;
    orderBy?: DanceClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customRoutines: <T = FragmentableArray<CustomRoutine>>(args?: {
    where?: CustomRoutineWhereInput;
    orderBy?: CustomRoutineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  avatar: () => Promise<String>;
  avatarId: () => Promise<String>;
  lastName: () => Promise<String>;
  studios: <T = FragmentableArray<Studio>>(args?: {
    where?: StudioWhereInput;
    orderBy?: StudioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DancerSubscription
  extends Promise<AsyncIterator<Dancer>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  parent: <T = ParentSubscription>() => T;
  requests: <T = EnrollmentRequestSubscription>() => T;
  danceClasses: <T = Promise<AsyncIterator<DanceClassSubscription>>>(args?: {
    where?: DanceClassWhereInput;
    orderBy?: DanceClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customRoutines: <
    T = Promise<AsyncIterator<CustomRoutineSubscription>>
  >(args?: {
    where?: CustomRoutineWhereInput;
    orderBy?: CustomRoutineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  avatar: () => Promise<AsyncIterator<String>>;
  avatarId: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  studios: <T = Promise<AsyncIterator<StudioSubscription>>>(args?: {
    where?: StudioWhereInput;
    orderBy?: StudioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DancerNullablePromise
  extends Promise<Dancer | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  parent: <T = ParentPromise>() => T;
  requests: <T = EnrollmentRequestPromise>() => T;
  danceClasses: <T = FragmentableArray<DanceClass>>(args?: {
    where?: DanceClassWhereInput;
    orderBy?: DanceClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customRoutines: <T = FragmentableArray<CustomRoutine>>(args?: {
    where?: CustomRoutineWhereInput;
    orderBy?: CustomRoutineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  avatar: () => Promise<String>;
  avatarId: () => Promise<String>;
  lastName: () => Promise<String>;
  studios: <T = FragmentableArray<Studio>>(args?: {
    where?: StudioWhereInput;
    orderBy?: StudioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Parent {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  id: ID_Output;
  email: String;
  firstName: String;
  lastName?: String;
  userType: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  accessRequests: ID_Output[];
  agreeToTerms?: DateTimeOutput;
  readPrivacy?: DateTimeOutput;
}

export interface ParentPromise extends Promise<Parent>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  userType: () => Promise<String>;
  dancers: <T = FragmentableArray<Dancer>>(args?: {
    where?: DancerWhereInput;
    orderBy?: DancerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  password: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  customRoutines: <T = FragmentableArray<CustomRoutine>>(args?: {
    where?: CustomRoutineWhereInput;
    orderBy?: CustomRoutineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  studios: <T = FragmentableArray<Studio>>(args?: {
    where?: StudioWhereInput;
    orderBy?: StudioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  accessRequests: () => Promise<ID_Output[]>;
  agreeToTerms: () => Promise<DateTimeOutput>;
  readPrivacy: () => Promise<DateTimeOutput>;
}

export interface ParentSubscription
  extends Promise<AsyncIterator<Parent>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  userType: () => Promise<AsyncIterator<String>>;
  dancers: <T = Promise<AsyncIterator<DancerSubscription>>>(args?: {
    where?: DancerWhereInput;
    orderBy?: DancerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  password: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  customRoutines: <
    T = Promise<AsyncIterator<CustomRoutineSubscription>>
  >(args?: {
    where?: CustomRoutineWhereInput;
    orderBy?: CustomRoutineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  studios: <T = Promise<AsyncIterator<StudioSubscription>>>(args?: {
    where?: StudioWhereInput;
    orderBy?: StudioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  accessRequests: () => Promise<AsyncIterator<ID_Output[]>>;
  agreeToTerms: () => Promise<AsyncIterator<DateTimeOutput>>;
  readPrivacy: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ParentNullablePromise
  extends Promise<Parent | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  userType: () => Promise<String>;
  dancers: <T = FragmentableArray<Dancer>>(args?: {
    where?: DancerWhereInput;
    orderBy?: DancerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  password: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  customRoutines: <T = FragmentableArray<CustomRoutine>>(args?: {
    where?: CustomRoutineWhereInput;
    orderBy?: CustomRoutineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  studios: <T = FragmentableArray<Studio>>(args?: {
    where?: StudioWhereInput;
    orderBy?: StudioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  accessRequests: () => Promise<ID_Output[]>;
  agreeToTerms: () => Promise<DateTimeOutput>;
  readPrivacy: () => Promise<DateTimeOutput>;
}

export interface CustomRoutine {
  custom: Boolean;
  id: ID_Output;
  name: String;
  music?: String;
  musicId?: String;
  style?: String;
  competitiveLevel?: String;
  ageDivision?: String;
  performanceName?: String;
  day?: String;
  startTime?: String;
  endTime?: String;
  shoes?: String;
  tights?: String;
  notes?: String;
  type?: String;
  entryNumber?: String;
  entryTime?: String;
  entryDay?: String;
}

export interface CustomRoutinePromise
  extends Promise<CustomRoutine>,
    Fragmentable {
  custom: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  studio: <T = StudioPromise>() => T;
  parent: <T = ParentPromise>() => T;
  music: () => Promise<String>;
  musicId: () => Promise<String>;
  style: () => Promise<String>;
  competitiveLevel: () => Promise<String>;
  ageDivision: () => Promise<String>;
  performanceName: () => Promise<String>;
  day: () => Promise<String>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
  shoes: () => Promise<String>;
  tights: () => Promise<String>;
  notes: () => Promise<String>;
  dancers: <T = FragmentableArray<Dancer>>(args?: {
    where?: DancerWhereInput;
    orderBy?: DancerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  type: () => Promise<String>;
  entryNumber: () => Promise<String>;
  entryTime: () => Promise<String>;
  entryDay: () => Promise<String>;
}

export interface CustomRoutineSubscription
  extends Promise<AsyncIterator<CustomRoutine>>,
    Fragmentable {
  custom: () => Promise<AsyncIterator<Boolean>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  studio: <T = StudioSubscription>() => T;
  parent: <T = ParentSubscription>() => T;
  music: () => Promise<AsyncIterator<String>>;
  musicId: () => Promise<AsyncIterator<String>>;
  style: () => Promise<AsyncIterator<String>>;
  competitiveLevel: () => Promise<AsyncIterator<String>>;
  ageDivision: () => Promise<AsyncIterator<String>>;
  performanceName: () => Promise<AsyncIterator<String>>;
  day: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<String>>;
  endTime: () => Promise<AsyncIterator<String>>;
  shoes: () => Promise<AsyncIterator<String>>;
  tights: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
  dancers: <T = Promise<AsyncIterator<DancerSubscription>>>(args?: {
    where?: DancerWhereInput;
    orderBy?: DancerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  type: () => Promise<AsyncIterator<String>>;
  entryNumber: () => Promise<AsyncIterator<String>>;
  entryTime: () => Promise<AsyncIterator<String>>;
  entryDay: () => Promise<AsyncIterator<String>>;
}

export interface CustomRoutineNullablePromise
  extends Promise<CustomRoutine | null>,
    Fragmentable {
  custom: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  studio: <T = StudioPromise>() => T;
  parent: <T = ParentPromise>() => T;
  music: () => Promise<String>;
  musicId: () => Promise<String>;
  style: () => Promise<String>;
  competitiveLevel: () => Promise<String>;
  ageDivision: () => Promise<String>;
  performanceName: () => Promise<String>;
  day: () => Promise<String>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
  shoes: () => Promise<String>;
  tights: () => Promise<String>;
  notes: () => Promise<String>;
  dancers: <T = FragmentableArray<Dancer>>(args?: {
    where?: DancerWhereInput;
    orderBy?: DancerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  type: () => Promise<String>;
  entryNumber: () => Promise<String>;
  entryTime: () => Promise<String>;
  entryDay: () => Promise<String>;
}

export interface EnrollmentRequest {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface EnrollmentRequestPromise
  extends Promise<EnrollmentRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  studio: <T = StudioPromise>() => T;
  parent: <T = ParentPromise>() => T;
  dancer: <T = DancerPromise>() => T;
  classesRequested: <T = FragmentableArray<DanceClass>>(args?: {
    where?: DanceClassWhereInput;
    orderBy?: DanceClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface EnrollmentRequestSubscription
  extends Promise<AsyncIterator<EnrollmentRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  studio: <T = StudioSubscription>() => T;
  parent: <T = ParentSubscription>() => T;
  dancer: <T = DancerSubscription>() => T;
  classesRequested: <
    T = Promise<AsyncIterator<DanceClassSubscription>>
  >(args?: {
    where?: DanceClassWhereInput;
    orderBy?: DanceClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EnrollmentRequestNullablePromise
  extends Promise<EnrollmentRequest | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  studio: <T = StudioPromise>() => T;
  parent: <T = ParentPromise>() => T;
  dancer: <T = DancerPromise>() => T;
  classesRequested: <T = FragmentableArray<DanceClass>>(args?: {
    where?: DanceClassWhereInput;
    orderBy?: DanceClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface MakeupSet {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  id: ID_Output;
  name: String;
  lipstick?: String;
  eyeShadow?: String;
  eyeLids?: String;
  eyeCrease?: String;
  eyeLiner?: String;
  eyelashes?: String;
  foundation?: String;
  powder?: String;
  blush?: String;
  bronzer?: String;
  applyToCategories?: String;
  notes?: String;
}

export interface MakeupSetPromise extends Promise<MakeupSet>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  studio: <T = StudioPromise>() => T;
  lipstick: () => Promise<String>;
  eyeShadow: () => Promise<String>;
  eyeLids: () => Promise<String>;
  eyeCrease: () => Promise<String>;
  eyeLiner: () => Promise<String>;
  eyelashes: () => Promise<String>;
  foundation: () => Promise<String>;
  powder: () => Promise<String>;
  blush: () => Promise<String>;
  bronzer: () => Promise<String>;
  applyToCategories: () => Promise<String>;
  notes: () => Promise<String>;
  danceClasses: <T = FragmentableArray<DanceClass>>(args?: {
    where?: DanceClassWhereInput;
    orderBy?: DanceClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MakeupSetSubscription
  extends Promise<AsyncIterator<MakeupSet>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  studio: <T = StudioSubscription>() => T;
  lipstick: () => Promise<AsyncIterator<String>>;
  eyeShadow: () => Promise<AsyncIterator<String>>;
  eyeLids: () => Promise<AsyncIterator<String>>;
  eyeCrease: () => Promise<AsyncIterator<String>>;
  eyeLiner: () => Promise<AsyncIterator<String>>;
  eyelashes: () => Promise<AsyncIterator<String>>;
  foundation: () => Promise<AsyncIterator<String>>;
  powder: () => Promise<AsyncIterator<String>>;
  blush: () => Promise<AsyncIterator<String>>;
  bronzer: () => Promise<AsyncIterator<String>>;
  applyToCategories: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
  danceClasses: <T = Promise<AsyncIterator<DanceClassSubscription>>>(args?: {
    where?: DanceClassWhereInput;
    orderBy?: DanceClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MakeupSetNullablePromise
  extends Promise<MakeupSet | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  studio: <T = StudioPromise>() => T;
  lipstick: () => Promise<String>;
  eyeShadow: () => Promise<String>;
  eyeLids: () => Promise<String>;
  eyeCrease: () => Promise<String>;
  eyeLiner: () => Promise<String>;
  eyelashes: () => Promise<String>;
  foundation: () => Promise<String>;
  powder: () => Promise<String>;
  blush: () => Promise<String>;
  bronzer: () => Promise<String>;
  applyToCategories: () => Promise<String>;
  notes: () => Promise<String>;
  danceClasses: <T = FragmentableArray<DanceClass>>(args?: {
    where?: DanceClassWhereInput;
    orderBy?: DanceClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface HairStyle {
  id: ID_Output;
  name: String;
  description?: String;
  image?: String;
  link?: String;
}

export interface HairStylePromise extends Promise<HairStyle>, Fragmentable {
  studio: <T = StudioPromise>() => T;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  link: () => Promise<String>;
}

export interface HairStyleSubscription
  extends Promise<AsyncIterator<HairStyle>>,
    Fragmentable {
  studio: <T = StudioSubscription>() => T;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
}

export interface HairStyleNullablePromise
  extends Promise<HairStyle | null>,
    Fragmentable {
  studio: <T = StudioPromise>() => T;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  link: () => Promise<String>;
}

export interface StudioEvent {
  id: ID_Output;
  name: String;
  type: String;
  appliesTo: String[];
  beginDate?: DateTimeOutput;
  endDate?: DateTimeOutput;
  location?: String;
  address1?: String;
  address2?: String;
  city?: String;
  state?: String;
  zip?: String;
  url?: String;
  notes?: String;
}

export interface StudioEventPromise extends Promise<StudioEvent>, Fragmentable {
  id: () => Promise<ID_Output>;
  studio: <T = StudioPromise>() => T;
  name: () => Promise<String>;
  type: () => Promise<String>;
  appliesTo: () => Promise<String[]>;
  beginDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  location: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<String>;
  url: () => Promise<String>;
  notes: () => Promise<String>;
}

export interface StudioEventSubscription
  extends Promise<AsyncIterator<StudioEvent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  studio: <T = StudioSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  appliesTo: () => Promise<AsyncIterator<String[]>>;
  beginDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  location: () => Promise<AsyncIterator<String>>;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
}

export interface StudioEventNullablePromise
  extends Promise<StudioEvent | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  studio: <T = StudioPromise>() => T;
  name: () => Promise<String>;
  type: () => Promise<String>;
  appliesTo: () => Promise<String[]>;
  beginDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  location: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<String>;
  url: () => Promise<String>;
  notes: () => Promise<String>;
}

export interface AccessRequestConnection {
  pageInfo: PageInfo;
  edges: AccessRequestEdge[];
}

export interface AccessRequestConnectionPromise
  extends Promise<AccessRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AccessRequestEdge>>() => T;
  aggregate: <T = AggregateAccessRequestPromise>() => T;
}

export interface AccessRequestConnectionSubscription
  extends Promise<AsyncIterator<AccessRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AccessRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAccessRequestSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AccessRequestEdge {
  node: AccessRequest;
  cursor: String;
}

export interface AccessRequestEdgePromise
  extends Promise<AccessRequestEdge>,
    Fragmentable {
  node: <T = AccessRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AccessRequestEdgeSubscription
  extends Promise<AsyncIterator<AccessRequestEdge>>,
    Fragmentable {
  node: <T = AccessRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAccessRequest {
  count: Int;
}

export interface AggregateAccessRequestPromise
  extends Promise<AggregateAccessRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAccessRequestSubscription
  extends Promise<AsyncIterator<AggregateAccessRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomRoutineConnection {
  pageInfo: PageInfo;
  edges: CustomRoutineEdge[];
}

export interface CustomRoutineConnectionPromise
  extends Promise<CustomRoutineConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomRoutineEdge>>() => T;
  aggregate: <T = AggregateCustomRoutinePromise>() => T;
}

export interface CustomRoutineConnectionSubscription
  extends Promise<AsyncIterator<CustomRoutineConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomRoutineEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomRoutineSubscription>() => T;
}

export interface CustomRoutineEdge {
  node: CustomRoutine;
  cursor: String;
}

export interface CustomRoutineEdgePromise
  extends Promise<CustomRoutineEdge>,
    Fragmentable {
  node: <T = CustomRoutinePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomRoutineEdgeSubscription
  extends Promise<AsyncIterator<CustomRoutineEdge>>,
    Fragmentable {
  node: <T = CustomRoutineSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCustomRoutine {
  count: Int;
}

export interface AggregateCustomRoutinePromise
  extends Promise<AggregateCustomRoutine>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomRoutineSubscription
  extends Promise<AsyncIterator<AggregateCustomRoutine>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DanceClassConnection {
  pageInfo: PageInfo;
  edges: DanceClassEdge[];
}

export interface DanceClassConnectionPromise
  extends Promise<DanceClassConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DanceClassEdge>>() => T;
  aggregate: <T = AggregateDanceClassPromise>() => T;
}

export interface DanceClassConnectionSubscription
  extends Promise<AsyncIterator<DanceClassConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DanceClassEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDanceClassSubscription>() => T;
}

export interface DanceClassEdge {
  node: DanceClass;
  cursor: String;
}

export interface DanceClassEdgePromise
  extends Promise<DanceClassEdge>,
    Fragmentable {
  node: <T = DanceClassPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DanceClassEdgeSubscription
  extends Promise<AsyncIterator<DanceClassEdge>>,
    Fragmentable {
  node: <T = DanceClassSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDanceClass {
  count: Int;
}

export interface AggregateDanceClassPromise
  extends Promise<AggregateDanceClass>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDanceClassSubscription
  extends Promise<AsyncIterator<AggregateDanceClass>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DancerConnection {
  pageInfo: PageInfo;
  edges: DancerEdge[];
}

export interface DancerConnectionPromise
  extends Promise<DancerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DancerEdge>>() => T;
  aggregate: <T = AggregateDancerPromise>() => T;
}

export interface DancerConnectionSubscription
  extends Promise<AsyncIterator<DancerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DancerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDancerSubscription>() => T;
}

export interface DancerEdge {
  node: Dancer;
  cursor: String;
}

export interface DancerEdgePromise extends Promise<DancerEdge>, Fragmentable {
  node: <T = DancerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DancerEdgeSubscription
  extends Promise<AsyncIterator<DancerEdge>>,
    Fragmentable {
  node: <T = DancerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDancer {
  count: Int;
}

export interface AggregateDancerPromise
  extends Promise<AggregateDancer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDancerSubscription
  extends Promise<AsyncIterator<AggregateDancer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EnrollmentRequestConnection {
  pageInfo: PageInfo;
  edges: EnrollmentRequestEdge[];
}

export interface EnrollmentRequestConnectionPromise
  extends Promise<EnrollmentRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EnrollmentRequestEdge>>() => T;
  aggregate: <T = AggregateEnrollmentRequestPromise>() => T;
}

export interface EnrollmentRequestConnectionSubscription
  extends Promise<AsyncIterator<EnrollmentRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EnrollmentRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEnrollmentRequestSubscription>() => T;
}

export interface EnrollmentRequestEdge {
  node: EnrollmentRequest;
  cursor: String;
}

export interface EnrollmentRequestEdgePromise
  extends Promise<EnrollmentRequestEdge>,
    Fragmentable {
  node: <T = EnrollmentRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EnrollmentRequestEdgeSubscription
  extends Promise<AsyncIterator<EnrollmentRequestEdge>>,
    Fragmentable {
  node: <T = EnrollmentRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEnrollmentRequest {
  count: Int;
}

export interface AggregateEnrollmentRequestPromise
  extends Promise<AggregateEnrollmentRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEnrollmentRequestSubscription
  extends Promise<AsyncIterator<AggregateEnrollmentRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HairStyleConnection {
  pageInfo: PageInfo;
  edges: HairStyleEdge[];
}

export interface HairStyleConnectionPromise
  extends Promise<HairStyleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HairStyleEdge>>() => T;
  aggregate: <T = AggregateHairStylePromise>() => T;
}

export interface HairStyleConnectionSubscription
  extends Promise<AsyncIterator<HairStyleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HairStyleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHairStyleSubscription>() => T;
}

export interface HairStyleEdge {
  node: HairStyle;
  cursor: String;
}

export interface HairStyleEdgePromise
  extends Promise<HairStyleEdge>,
    Fragmentable {
  node: <T = HairStylePromise>() => T;
  cursor: () => Promise<String>;
}

export interface HairStyleEdgeSubscription
  extends Promise<AsyncIterator<HairStyleEdge>>,
    Fragmentable {
  node: <T = HairStyleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHairStyle {
  count: Int;
}

export interface AggregateHairStylePromise
  extends Promise<AggregateHairStyle>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHairStyleSubscription
  extends Promise<AsyncIterator<AggregateHairStyle>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MakeupSetConnection {
  pageInfo: PageInfo;
  edges: MakeupSetEdge[];
}

export interface MakeupSetConnectionPromise
  extends Promise<MakeupSetConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MakeupSetEdge>>() => T;
  aggregate: <T = AggregateMakeupSetPromise>() => T;
}

export interface MakeupSetConnectionSubscription
  extends Promise<AsyncIterator<MakeupSetConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MakeupSetEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMakeupSetSubscription>() => T;
}

export interface MakeupSetEdge {
  node: MakeupSet;
  cursor: String;
}

export interface MakeupSetEdgePromise
  extends Promise<MakeupSetEdge>,
    Fragmentable {
  node: <T = MakeupSetPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MakeupSetEdgeSubscription
  extends Promise<AsyncIterator<MakeupSetEdge>>,
    Fragmentable {
  node: <T = MakeupSetSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMakeupSet {
  count: Int;
}

export interface AggregateMakeupSetPromise
  extends Promise<AggregateMakeupSet>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMakeupSetSubscription
  extends Promise<AsyncIterator<AggregateMakeupSet>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ParentConnection {
  pageInfo: PageInfo;
  edges: ParentEdge[];
}

export interface ParentConnectionPromise
  extends Promise<ParentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ParentEdge>>() => T;
  aggregate: <T = AggregateParentPromise>() => T;
}

export interface ParentConnectionSubscription
  extends Promise<AsyncIterator<ParentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ParentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateParentSubscription>() => T;
}

export interface ParentEdge {
  node: Parent;
  cursor: String;
}

export interface ParentEdgePromise extends Promise<ParentEdge>, Fragmentable {
  node: <T = ParentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ParentEdgeSubscription
  extends Promise<AsyncIterator<ParentEdge>>,
    Fragmentable {
  node: <T = ParentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateParent {
  count: Int;
}

export interface AggregateParentPromise
  extends Promise<AggregateParent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateParentSubscription
  extends Promise<AsyncIterator<AggregateParent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ParentEvent {
  id: ID_Output;
  name: String;
  type: String;
  dancerIds: ID_Output[];
  appliesTo: String[];
  beginDate?: DateTimeOutput;
  endDate?: DateTimeOutput;
  location?: String;
  address1?: String;
  address2?: String;
  city?: String;
  state?: String;
  zip?: String;
  url?: String;
  notes?: String;
}

export interface ParentEventPromise extends Promise<ParentEvent>, Fragmentable {
  id: () => Promise<ID_Output>;
  parent: <T = ParentPromise>() => T;
  studio: <T = StudioPromise>() => T;
  name: () => Promise<String>;
  type: () => Promise<String>;
  dancerIds: () => Promise<ID_Output[]>;
  appliesTo: () => Promise<String[]>;
  beginDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  location: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<String>;
  url: () => Promise<String>;
  notes: () => Promise<String>;
}

export interface ParentEventSubscription
  extends Promise<AsyncIterator<ParentEvent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parent: <T = ParentSubscription>() => T;
  studio: <T = StudioSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  dancerIds: () => Promise<AsyncIterator<ID_Output[]>>;
  appliesTo: () => Promise<AsyncIterator<String[]>>;
  beginDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  location: () => Promise<AsyncIterator<String>>;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
}

export interface ParentEventNullablePromise
  extends Promise<ParentEvent | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parent: <T = ParentPromise>() => T;
  studio: <T = StudioPromise>() => T;
  name: () => Promise<String>;
  type: () => Promise<String>;
  dancerIds: () => Promise<ID_Output[]>;
  appliesTo: () => Promise<String[]>;
  beginDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  location: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<String>;
  url: () => Promise<String>;
  notes: () => Promise<String>;
}

export interface ParentEventConnection {
  pageInfo: PageInfo;
  edges: ParentEventEdge[];
}

export interface ParentEventConnectionPromise
  extends Promise<ParentEventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ParentEventEdge>>() => T;
  aggregate: <T = AggregateParentEventPromise>() => T;
}

export interface ParentEventConnectionSubscription
  extends Promise<AsyncIterator<ParentEventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ParentEventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateParentEventSubscription>() => T;
}

export interface ParentEventEdge {
  node: ParentEvent;
  cursor: String;
}

export interface ParentEventEdgePromise
  extends Promise<ParentEventEdge>,
    Fragmentable {
  node: <T = ParentEventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ParentEventEdgeSubscription
  extends Promise<AsyncIterator<ParentEventEdge>>,
    Fragmentable {
  node: <T = ParentEventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateParentEvent {
  count: Int;
}

export interface AggregateParentEventPromise
  extends Promise<AggregateParentEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateParentEventSubscription
  extends Promise<AsyncIterator<AggregateParentEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ParentNote {
  id: ID_Output;
  note: String;
}

export interface ParentNotePromise extends Promise<ParentNote>, Fragmentable {
  id: () => Promise<ID_Output>;
  parent: <T = ParentPromise>() => T;
  dance: <T = DanceClassPromise>() => T;
  note: () => Promise<String>;
}

export interface ParentNoteSubscription
  extends Promise<AsyncIterator<ParentNote>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parent: <T = ParentSubscription>() => T;
  dance: <T = DanceClassSubscription>() => T;
  note: () => Promise<AsyncIterator<String>>;
}

export interface ParentNoteNullablePromise
  extends Promise<ParentNote | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parent: <T = ParentPromise>() => T;
  dance: <T = DanceClassPromise>() => T;
  note: () => Promise<String>;
}

export interface ParentNoteConnection {
  pageInfo: PageInfo;
  edges: ParentNoteEdge[];
}

export interface ParentNoteConnectionPromise
  extends Promise<ParentNoteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ParentNoteEdge>>() => T;
  aggregate: <T = AggregateParentNotePromise>() => T;
}

export interface ParentNoteConnectionSubscription
  extends Promise<AsyncIterator<ParentNoteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ParentNoteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateParentNoteSubscription>() => T;
}

export interface ParentNoteEdge {
  node: ParentNote;
  cursor: String;
}

export interface ParentNoteEdgePromise
  extends Promise<ParentNoteEdge>,
    Fragmentable {
  node: <T = ParentNotePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ParentNoteEdgeSubscription
  extends Promise<AsyncIterator<ParentNoteEdge>>,
    Fragmentable {
  node: <T = ParentNoteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateParentNote {
  count: Int;
}

export interface AggregateParentNotePromise
  extends Promise<AggregateParentNote>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateParentNoteSubscription
  extends Promise<AsyncIterator<AggregateParentNote>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudioConnection {
  pageInfo: PageInfo;
  edges: StudioEdge[];
}

export interface StudioConnectionPromise
  extends Promise<StudioConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudioEdge>>() => T;
  aggregate: <T = AggregateStudioPromise>() => T;
}

export interface StudioConnectionSubscription
  extends Promise<AsyncIterator<StudioConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudioEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudioSubscription>() => T;
}

export interface StudioEdge {
  node: Studio;
  cursor: String;
}

export interface StudioEdgePromise extends Promise<StudioEdge>, Fragmentable {
  node: <T = StudioPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudioEdgeSubscription
  extends Promise<AsyncIterator<StudioEdge>>,
    Fragmentable {
  node: <T = StudioSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudio {
  count: Int;
}

export interface AggregateStudioPromise
  extends Promise<AggregateStudio>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudioSubscription
  extends Promise<AsyncIterator<AggregateStudio>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudioEventConnection {
  pageInfo: PageInfo;
  edges: StudioEventEdge[];
}

export interface StudioEventConnectionPromise
  extends Promise<StudioEventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudioEventEdge>>() => T;
  aggregate: <T = AggregateStudioEventPromise>() => T;
}

export interface StudioEventConnectionSubscription
  extends Promise<AsyncIterator<StudioEventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudioEventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudioEventSubscription>() => T;
}

export interface StudioEventEdge {
  node: StudioEvent;
  cursor: String;
}

export interface StudioEventEdgePromise
  extends Promise<StudioEventEdge>,
    Fragmentable {
  node: <T = StudioEventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudioEventEdgeSubscription
  extends Promise<AsyncIterator<StudioEventEdge>>,
    Fragmentable {
  node: <T = StudioEventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudioEvent {
  count: Int;
}

export interface AggregateStudioEventPromise
  extends Promise<AggregateStudioEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudioEventSubscription
  extends Promise<AsyncIterator<AggregateStudioEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AccessRequestSubscriptionPayload {
  mutation: MutationType;
  node: AccessRequest;
  updatedFields: String[];
  previousValues: AccessRequestPreviousValues;
}

export interface AccessRequestSubscriptionPayloadPromise
  extends Promise<AccessRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AccessRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AccessRequestPreviousValuesPromise>() => T;
}

export interface AccessRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AccessRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AccessRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AccessRequestPreviousValuesSubscription>() => T;
}

export interface AccessRequestPreviousValues {
  id: ID_Output;
}

export interface AccessRequestPreviousValuesPromise
  extends Promise<AccessRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface AccessRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<AccessRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface CustomRoutineSubscriptionPayload {
  mutation: MutationType;
  node: CustomRoutine;
  updatedFields: String[];
  previousValues: CustomRoutinePreviousValues;
}

export interface CustomRoutineSubscriptionPayloadPromise
  extends Promise<CustomRoutineSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomRoutinePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomRoutinePreviousValuesPromise>() => T;
}

export interface CustomRoutineSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomRoutineSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomRoutineSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomRoutinePreviousValuesSubscription>() => T;
}

export interface CustomRoutinePreviousValues {
  custom: Boolean;
  id: ID_Output;
  name: String;
  music?: String;
  musicId?: String;
  style?: String;
  competitiveLevel?: String;
  ageDivision?: String;
  performanceName?: String;
  day?: String;
  startTime?: String;
  endTime?: String;
  shoes?: String;
  tights?: String;
  notes?: String;
  type?: String;
  entryNumber?: String;
  entryTime?: String;
  entryDay?: String;
}

export interface CustomRoutinePreviousValuesPromise
  extends Promise<CustomRoutinePreviousValues>,
    Fragmentable {
  custom: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  music: () => Promise<String>;
  musicId: () => Promise<String>;
  style: () => Promise<String>;
  competitiveLevel: () => Promise<String>;
  ageDivision: () => Promise<String>;
  performanceName: () => Promise<String>;
  day: () => Promise<String>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
  shoes: () => Promise<String>;
  tights: () => Promise<String>;
  notes: () => Promise<String>;
  type: () => Promise<String>;
  entryNumber: () => Promise<String>;
  entryTime: () => Promise<String>;
  entryDay: () => Promise<String>;
}

export interface CustomRoutinePreviousValuesSubscription
  extends Promise<AsyncIterator<CustomRoutinePreviousValues>>,
    Fragmentable {
  custom: () => Promise<AsyncIterator<Boolean>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  music: () => Promise<AsyncIterator<String>>;
  musicId: () => Promise<AsyncIterator<String>>;
  style: () => Promise<AsyncIterator<String>>;
  competitiveLevel: () => Promise<AsyncIterator<String>>;
  ageDivision: () => Promise<AsyncIterator<String>>;
  performanceName: () => Promise<AsyncIterator<String>>;
  day: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<String>>;
  endTime: () => Promise<AsyncIterator<String>>;
  shoes: () => Promise<AsyncIterator<String>>;
  tights: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  entryNumber: () => Promise<AsyncIterator<String>>;
  entryTime: () => Promise<AsyncIterator<String>>;
  entryDay: () => Promise<AsyncIterator<String>>;
}

export interface DanceClassSubscriptionPayload {
  mutation: MutationType;
  node: DanceClass;
  updatedFields: String[];
  previousValues: DanceClassPreviousValues;
}

export interface DanceClassSubscriptionPayloadPromise
  extends Promise<DanceClassSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DanceClassPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DanceClassPreviousValuesPromise>() => T;
}

export interface DanceClassSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DanceClassSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DanceClassSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DanceClassPreviousValuesSubscription>() => T;
}

export interface DanceClassPreviousValues {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  id: ID_Output;
  name: String;
  music?: String;
  musicId?: String;
  performanceName?: String;
  day?: String;
  startTime?: String;
  endTime?: String;
  competitiveLevel?: String;
  ageDivision?: String;
  style?: String;
  tights?: String;
  shoes?: String;
  notes?: String;
  size: String;
  custom: Boolean;
  entryNumber?: String;
  entryTime?: String;
  entryDay?: String;
  videoUrl?: String;
  videoId?: String;
}

export interface DanceClassPreviousValuesPromise
  extends Promise<DanceClassPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  music: () => Promise<String>;
  musicId: () => Promise<String>;
  performanceName: () => Promise<String>;
  day: () => Promise<String>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
  competitiveLevel: () => Promise<String>;
  ageDivision: () => Promise<String>;
  style: () => Promise<String>;
  tights: () => Promise<String>;
  shoes: () => Promise<String>;
  notes: () => Promise<String>;
  size: () => Promise<String>;
  custom: () => Promise<Boolean>;
  entryNumber: () => Promise<String>;
  entryTime: () => Promise<String>;
  entryDay: () => Promise<String>;
  videoUrl: () => Promise<String>;
  videoId: () => Promise<String>;
}

export interface DanceClassPreviousValuesSubscription
  extends Promise<AsyncIterator<DanceClassPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  music: () => Promise<AsyncIterator<String>>;
  musicId: () => Promise<AsyncIterator<String>>;
  performanceName: () => Promise<AsyncIterator<String>>;
  day: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<String>>;
  endTime: () => Promise<AsyncIterator<String>>;
  competitiveLevel: () => Promise<AsyncIterator<String>>;
  ageDivision: () => Promise<AsyncIterator<String>>;
  style: () => Promise<AsyncIterator<String>>;
  tights: () => Promise<AsyncIterator<String>>;
  shoes: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<String>>;
  custom: () => Promise<AsyncIterator<Boolean>>;
  entryNumber: () => Promise<AsyncIterator<String>>;
  entryTime: () => Promise<AsyncIterator<String>>;
  entryDay: () => Promise<AsyncIterator<String>>;
  videoUrl: () => Promise<AsyncIterator<String>>;
  videoId: () => Promise<AsyncIterator<String>>;
}

export interface DancerSubscriptionPayload {
  mutation: MutationType;
  node: Dancer;
  updatedFields: String[];
  previousValues: DancerPreviousValues;
}

export interface DancerSubscriptionPayloadPromise
  extends Promise<DancerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DancerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DancerPreviousValuesPromise>() => T;
}

export interface DancerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DancerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DancerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DancerPreviousValuesSubscription>() => T;
}

export interface DancerPreviousValues {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  id: ID_Output;
  firstName: String;
  avatar?: String;
  avatarId?: String;
  lastName?: String;
}

export interface DancerPreviousValuesPromise
  extends Promise<DancerPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  avatar: () => Promise<String>;
  avatarId: () => Promise<String>;
  lastName: () => Promise<String>;
}

export interface DancerPreviousValuesSubscription
  extends Promise<AsyncIterator<DancerPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  avatarId: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
}

export interface EnrollmentRequestSubscriptionPayload {
  mutation: MutationType;
  node: EnrollmentRequest;
  updatedFields: String[];
  previousValues: EnrollmentRequestPreviousValues;
}

export interface EnrollmentRequestSubscriptionPayloadPromise
  extends Promise<EnrollmentRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EnrollmentRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EnrollmentRequestPreviousValuesPromise>() => T;
}

export interface EnrollmentRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EnrollmentRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EnrollmentRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EnrollmentRequestPreviousValuesSubscription>() => T;
}

export interface EnrollmentRequestPreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface EnrollmentRequestPreviousValuesPromise
  extends Promise<EnrollmentRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface EnrollmentRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<EnrollmentRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HairStyleSubscriptionPayload {
  mutation: MutationType;
  node: HairStyle;
  updatedFields: String[];
  previousValues: HairStylePreviousValues;
}

export interface HairStyleSubscriptionPayloadPromise
  extends Promise<HairStyleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HairStylePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HairStylePreviousValuesPromise>() => T;
}

export interface HairStyleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HairStyleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HairStyleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HairStylePreviousValuesSubscription>() => T;
}

export interface HairStylePreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  image?: String;
  link?: String;
}

export interface HairStylePreviousValuesPromise
  extends Promise<HairStylePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  link: () => Promise<String>;
}

export interface HairStylePreviousValuesSubscription
  extends Promise<AsyncIterator<HairStylePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
}

export interface MakeupSetSubscriptionPayload {
  mutation: MutationType;
  node: MakeupSet;
  updatedFields: String[];
  previousValues: MakeupSetPreviousValues;
}

export interface MakeupSetSubscriptionPayloadPromise
  extends Promise<MakeupSetSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MakeupSetPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MakeupSetPreviousValuesPromise>() => T;
}

export interface MakeupSetSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MakeupSetSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MakeupSetSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MakeupSetPreviousValuesSubscription>() => T;
}

export interface MakeupSetPreviousValues {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  id: ID_Output;
  name: String;
  lipstick?: String;
  eyeShadow?: String;
  eyeLids?: String;
  eyeCrease?: String;
  eyeLiner?: String;
  eyelashes?: String;
  foundation?: String;
  powder?: String;
  blush?: String;
  bronzer?: String;
  applyToCategories?: String;
  notes?: String;
}

export interface MakeupSetPreviousValuesPromise
  extends Promise<MakeupSetPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  lipstick: () => Promise<String>;
  eyeShadow: () => Promise<String>;
  eyeLids: () => Promise<String>;
  eyeCrease: () => Promise<String>;
  eyeLiner: () => Promise<String>;
  eyelashes: () => Promise<String>;
  foundation: () => Promise<String>;
  powder: () => Promise<String>;
  blush: () => Promise<String>;
  bronzer: () => Promise<String>;
  applyToCategories: () => Promise<String>;
  notes: () => Promise<String>;
}

export interface MakeupSetPreviousValuesSubscription
  extends Promise<AsyncIterator<MakeupSetPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  lipstick: () => Promise<AsyncIterator<String>>;
  eyeShadow: () => Promise<AsyncIterator<String>>;
  eyeLids: () => Promise<AsyncIterator<String>>;
  eyeCrease: () => Promise<AsyncIterator<String>>;
  eyeLiner: () => Promise<AsyncIterator<String>>;
  eyelashes: () => Promise<AsyncIterator<String>>;
  foundation: () => Promise<AsyncIterator<String>>;
  powder: () => Promise<AsyncIterator<String>>;
  blush: () => Promise<AsyncIterator<String>>;
  bronzer: () => Promise<AsyncIterator<String>>;
  applyToCategories: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
}

export interface ParentSubscriptionPayload {
  mutation: MutationType;
  node: Parent;
  updatedFields: String[];
  previousValues: ParentPreviousValues;
}

export interface ParentSubscriptionPayloadPromise
  extends Promise<ParentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ParentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ParentPreviousValuesPromise>() => T;
}

export interface ParentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ParentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ParentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ParentPreviousValuesSubscription>() => T;
}

export interface ParentPreviousValues {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  id: ID_Output;
  email: String;
  firstName: String;
  lastName?: String;
  userType: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  accessRequests: ID_Output[];
  agreeToTerms?: DateTimeOutput;
  readPrivacy?: DateTimeOutput;
}

export interface ParentPreviousValuesPromise
  extends Promise<ParentPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  userType: () => Promise<String>;
  password: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  accessRequests: () => Promise<ID_Output[]>;
  agreeToTerms: () => Promise<DateTimeOutput>;
  readPrivacy: () => Promise<DateTimeOutput>;
}

export interface ParentPreviousValuesSubscription
  extends Promise<AsyncIterator<ParentPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  userType: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  accessRequests: () => Promise<AsyncIterator<ID_Output[]>>;
  agreeToTerms: () => Promise<AsyncIterator<DateTimeOutput>>;
  readPrivacy: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ParentEventSubscriptionPayload {
  mutation: MutationType;
  node: ParentEvent;
  updatedFields: String[];
  previousValues: ParentEventPreviousValues;
}

export interface ParentEventSubscriptionPayloadPromise
  extends Promise<ParentEventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ParentEventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ParentEventPreviousValuesPromise>() => T;
}

export interface ParentEventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ParentEventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ParentEventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ParentEventPreviousValuesSubscription>() => T;
}

export interface ParentEventPreviousValues {
  id: ID_Output;
  name: String;
  type: String;
  dancerIds: ID_Output[];
  appliesTo: String[];
  beginDate?: DateTimeOutput;
  endDate?: DateTimeOutput;
  location?: String;
  address1?: String;
  address2?: String;
  city?: String;
  state?: String;
  zip?: String;
  url?: String;
  notes?: String;
}

export interface ParentEventPreviousValuesPromise
  extends Promise<ParentEventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<String>;
  dancerIds: () => Promise<ID_Output[]>;
  appliesTo: () => Promise<String[]>;
  beginDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  location: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<String>;
  url: () => Promise<String>;
  notes: () => Promise<String>;
}

export interface ParentEventPreviousValuesSubscription
  extends Promise<AsyncIterator<ParentEventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  dancerIds: () => Promise<AsyncIterator<ID_Output[]>>;
  appliesTo: () => Promise<AsyncIterator<String[]>>;
  beginDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  location: () => Promise<AsyncIterator<String>>;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
}

export interface ParentNoteSubscriptionPayload {
  mutation: MutationType;
  node: ParentNote;
  updatedFields: String[];
  previousValues: ParentNotePreviousValues;
}

export interface ParentNoteSubscriptionPayloadPromise
  extends Promise<ParentNoteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ParentNotePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ParentNotePreviousValuesPromise>() => T;
}

export interface ParentNoteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ParentNoteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ParentNoteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ParentNotePreviousValuesSubscription>() => T;
}

export interface ParentNotePreviousValues {
  id: ID_Output;
  note: String;
}

export interface ParentNotePreviousValuesPromise
  extends Promise<ParentNotePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  note: () => Promise<String>;
}

export interface ParentNotePreviousValuesSubscription
  extends Promise<AsyncIterator<ParentNotePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  note: () => Promise<AsyncIterator<String>>;
}

export interface StudioSubscriptionPayload {
  mutation: MutationType;
  node: Studio;
  updatedFields: String[];
  previousValues: StudioPreviousValues;
}

export interface StudioSubscriptionPayloadPromise
  extends Promise<StudioSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudioPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudioPreviousValuesPromise>() => T;
}

export interface StudioSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudioSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudioSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudioPreviousValuesSubscription>() => T;
}

export interface StudioPreviousValues {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  id: ID_Output;
  email: String;
  studioName: String;
  userType: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  styles: String[];
  competitiveLevels: String[];
  ageDivisions: String[];
  website?: String;
  agreeToTerms?: DateTimeOutput;
  readPrivacy?: DateTimeOutput;
}

export interface StudioPreviousValuesPromise
  extends Promise<StudioPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  studioName: () => Promise<String>;
  userType: () => Promise<String>;
  password: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  styles: () => Promise<String[]>;
  competitiveLevels: () => Promise<String[]>;
  ageDivisions: () => Promise<String[]>;
  website: () => Promise<String>;
  agreeToTerms: () => Promise<DateTimeOutput>;
  readPrivacy: () => Promise<DateTimeOutput>;
}

export interface StudioPreviousValuesSubscription
  extends Promise<AsyncIterator<StudioPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  studioName: () => Promise<AsyncIterator<String>>;
  userType: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  styles: () => Promise<AsyncIterator<String[]>>;
  competitiveLevels: () => Promise<AsyncIterator<String[]>>;
  ageDivisions: () => Promise<AsyncIterator<String[]>>;
  website: () => Promise<AsyncIterator<String>>;
  agreeToTerms: () => Promise<AsyncIterator<DateTimeOutput>>;
  readPrivacy: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StudioEventSubscriptionPayload {
  mutation: MutationType;
  node: StudioEvent;
  updatedFields: String[];
  previousValues: StudioEventPreviousValues;
}

export interface StudioEventSubscriptionPayloadPromise
  extends Promise<StudioEventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudioEventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudioEventPreviousValuesPromise>() => T;
}

export interface StudioEventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudioEventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudioEventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudioEventPreviousValuesSubscription>() => T;
}

export interface StudioEventPreviousValues {
  id: ID_Output;
  name: String;
  type: String;
  appliesTo: String[];
  beginDate?: DateTimeOutput;
  endDate?: DateTimeOutput;
  location?: String;
  address1?: String;
  address2?: String;
  city?: String;
  state?: String;
  zip?: String;
  url?: String;
  notes?: String;
}

export interface StudioEventPreviousValuesPromise
  extends Promise<StudioEventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<String>;
  appliesTo: () => Promise<String[]>;
  beginDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  location: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<String>;
  url: () => Promise<String>;
  notes: () => Promise<String>;
}

export interface StudioEventPreviousValuesSubscription
  extends Promise<AsyncIterator<StudioEventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  appliesTo: () => Promise<AsyncIterator<String[]>>;
  beginDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  location: () => Promise<AsyncIterator<String>>;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Parent",
    embedded: false
  },
  {
    name: "Studio",
    embedded: false
  },
  {
    name: "Dancer",
    embedded: false
  },
  {
    name: "DanceClass",
    embedded: false
  },
  {
    name: "CustomRoutine",
    embedded: false
  },
  {
    name: "MakeupSet",
    embedded: false
  },
  {
    name: "HairStyle",
    embedded: false
  },
  {
    name: "ParentNote",
    embedded: false
  },
  {
    name: "StudioEvent",
    embedded: false
  },
  {
    name: "ParentEvent",
    embedded: false
  },
  {
    name: "EnrollmentRequest",
    embedded: false
  },
  {
    name: "AccessRequest",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
